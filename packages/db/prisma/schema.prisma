// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===== Enums =====

enum RoleLevel {
  L1 // Waiter
  L2 // Cashier/Supervisor
  L3 // Chef/Stock
  L4 // Manager/Accountant
  L5 // Owner/Admin
}

enum JobRole {
  OWNER
  MANAGER
  ACCOUNTANT
  PROCUREMENT
  STOCK_MANAGER
  SUPERVISOR
  CASHIER
  CHEF
  WAITER
  BARTENDER
  EVENT_MANAGER
}

enum TableStatus {
  AVAILABLE
  OCCUPIED
  RESERVED
  CLEANING
}

enum ReservationStatus {
  HELD
  CONFIRMED
  SEATED
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum ReservationSource {
  PHONE
  WALK_IN
  ONLINE
  INTERNAL
}

enum WaitlistStatus {
  WAITING
  SEATED
  DROPPED
}

enum ItemType {
  FOOD
  DRINK
}

enum OrderStatus {
  NEW
  SENT
  IN_KITCHEN
  READY
  SERVED
  VOIDED
  CLOSED
}

// M13.5: Payment status for order (separate from order lifecycle)
enum OrderPaymentStatus {
  UNPAID
  PARTIALLY_PAID
  PAID
  REFUNDED
}

enum SubscriptionStatus {
  ACTIVE
  GRACE
  PAST_DUE
  CANCELLED
}

enum SubscriptionEventType {
  RENEWAL_DUE
  RENEWED
  PAST_DUE
  CANCELLED
}

enum ServiceType {
  DINE_IN
  TAKEAWAY
}

enum StationTag {
  GRILL
  FRYER
  BAR
  KITCHEN
  OTHER
}

enum PaymentMethod {
  CASH
  CARD
  MOMO
  BANK_TRANSFER // M8.4: Bank transfer payments
  OTHER // M13.4: Catch-all for future methods
}

// M13.4: Payment status for POS payments lifecycle
enum PosPaymentStatus {
  PENDING
  AUTHORIZED
  CAPTURED
  VOIDED
  REFUNDED
  FAILED
}

// M13.4: Payment provider for card processing
enum PosPaymentProvider {
  INTERNAL // Cash or manual
  FAKE_CARD // Test provider
  STRIPE // Future
  SQUARE // Future
}

// M13.4: Cash session status
enum CashSessionStatus {
  OPEN
  CLOSED
}

enum DocumentCategory {
  INVOICE
  STOCK_RECEIPT
  CONTRACT
  HR_DOC
  BANK_STATEMENT
  PAYSLIP
  RESERVATION_DOC
  OTHER
}

enum StorageProvider {
  LOCAL
  S3
  GCS
}

enum BadgeState {
  ACTIVE
  REVOKED
  LOST
  RETURNED
}

enum ProcurementStrategy {
  SAFETY_STOCK
  FORECAST
}

enum ProcurementJobStatus {
  DRAFT
  APPROVED
  PLACED
}

// M11.10: Stocktake Session Status (6-state workflow)
enum StocktakeStatus {
  DRAFT // Created but not started
  IN_PROGRESS // Counting in progress, snapshot frozen
  SUBMITTED // Counting complete, awaiting approval
  APPROVED // Approved, ready for posting
  POSTED // Variances applied to ledger (terminal)
  VOID // Cancelled/voided (terminal)
}

enum PromotionEffectType {
  PERCENT_OFF
  FIXED_OFF
  HAPPY_HOUR
  BUNDLE
}

enum CashMovementType {
  PAID_IN
  PAID_OUT
  SAFE_DROP
  PICKUP
}

enum AccountType {
  ASSET
  LIABILITY
  EQUITY
  REVENUE
  COGS
  EXPENSE
}

enum PaymentTerms {
  NET7
  NET14
  NET30
}

enum BillStatus {
  DRAFT
  OPEN
  PARTIALLY_PAID // M8.4: Partial payment received
  PAID
  VOID
}

enum JournalEntryStatus {
  DRAFT
  POSTED
  REVERSED
}

enum InvoiceStatus {
  DRAFT
  OPEN
  PARTIALLY_PAID // M8.4: Partial payment received
  PAID
  VOID
}

// M8.5: Credit Note Status
enum CreditNoteStatus {
  DRAFT
  OPEN
  PARTIALLY_APPLIED // Some credits allocated
  APPLIED // All credits exhausted
  VOID
}

enum ReminderType {
  VENDOR_BILL
  UTILITY
}

enum ReminderChannel {
  EMAIL
  SLACK
}

enum EventBookingStatus {
  HELD
  CONFIRMED
  CANCELLED
}

// M10.17: Leave Management Enums
enum LeaveTypeCode {
  ANNUAL
  SICK
  UNPAID
  PARENTAL
  BEREAVEMENT
  JURY_DUTY
  OTHER
}

enum LeaveRequestStatus {
  DRAFT
  SUBMITTED
  APPROVED_STEP1 // M10.18: First approval in two-step process
  APPROVED
  REJECTED
  CANCELLED
}

enum ApprovalMode {
  SINGLE // Default: one approver
  TWO_STEP // Supervisor then Manager/Owner
}

enum AccrualMethod {
  NONE
  FIXED_MONTHLY
  HOURS_WORKED_RATE
}

enum LedgerEntryType {
  CREDIT
  DEBIT
}

// Legacy enum kept for backward compatibility
enum LeaveType {
  ANNUAL
  SICK
  UNPAID
  OTHER
}

enum ShiftSwapStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

// M10.11: Enhanced shift swap request status lifecycle
enum ShiftSwapRequestStatus {
  DRAFT
  REQUESTED
  ACCEPTED
  DECLINED
  APPROVED
  REJECTED
  APPLIED
  CANCELLED
}

// M10.11: Shift swap request type
enum ShiftSwapRequestType {
  DIRECT_SWAP
  OFFER_SHIFT
}

// M10.11: Workforce notification types
enum WorkforceNotificationType {
  SWAP_REQUESTED
  SWAP_ACCEPTED
  SWAP_DECLINED
  SWAP_APPROVED
  SWAP_REJECTED
  SWAP_APPLIED
  SWAP_CANCELLED
  SHIFT_OPENED
  OPEN_SHIFT_CLAIMED
  OPEN_SHIFT_CLAIM_APPROVED
  AVAILABILITY_UPDATED
  SCHEDULE_PUBLISHED // M10.14: Auto-scheduler published notification
}

// M10.1: Shift Scheduling Status Lifecycle
enum ShiftStatus {
  DRAFT
  PUBLISHED
  IN_PROGRESS
  COMPLETED
  APPROVED
  CANCELLED
}

enum TimeClockMethod {
  MSR
  PASSKEY
  PASSWORD
}

enum FeedbackChannel {
  POS // In-person tablet at POS terminal
  PORTAL // Customer web portal
  EMAIL // Email survey link
  QR // QR code on printed receipt
  SMS // SMS survey link
  KIOSK // Self-service kiosk
  OTHER // Default/unknown channel
}

enum NpsCategory {
  DETRACTOR // 0-6: Unhappy customers likely to churn
  PASSIVE // 7-8: Satisfied but not enthusiastic
  PROMOTER // 9-10: Loyal enthusiasts who will recommend
}

// M9.2: Deposit Management
enum DepositStatus {
  REQUIRED // Deposit requested but not paid
  PAID // Deposit captured (posted to liability)
  REFUNDED // Deposit refunded (reversal posted)
  APPLIED // Deposit applied to bill (liability â†’ revenue)
  FORFEITED // No-show deposit kept
}

// M9.5: Webhook Delivery Status
enum WebhookDeliveryStatus {
  PENDING
  ATTEMPTED
  DELIVERED
  FAILED
  DEAD_LETTER
}

// M9.5: Notification Outbox Status
enum NotificationOutboxStatus {
  PENDING
  SENT
  FAILED
  RETRYING
}

// M9.2: Notification Types
enum NotificationType {
  EMAIL
  SMS
  IN_APP
  WHATSAPP // M9.5
  PUSH // M9.5
}

enum NotificationEvent {
  CONFIRMED
  CANCELLED
  NO_SHOW
  DEPOSIT_PAID
  DEPOSIT_REFUNDED
  DEPOSIT_APPLIED
  REMINDER
  WAITLIST_READY
  BOOKING_CREATED // M9.4: Public booking created
  BOOKING_CANCELLED // M9.4: Public booking cancelled
  BOOKING_MODIFIED // M9.4: Public booking rescheduled
}

enum NotificationStatus {
  QUEUED
  SENT
  FAILED
}

// ===== Organization & Multi-tenancy =====

model Org {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branches                       Branch[]
  users                          User[]
  settings                       OrgSettings?
  devices                        Device[]
  floorPlans                     FloorPlan[]
  taxCategories                  TaxCategory[]
  modifierGroups                 ModifierGroup[]
  anomalyEvents                  AnomalyEvent[]
  alertChannels                  AlertChannel[]
  scheduledAlerts                ScheduledAlert[]
  reservations                   Reservation[]
  supportSessions                SupportSession[]
  spoutDevices                   SpoutDevice[]
  spoutEvents                    SpoutEvent[]
  ownerDigests                   OwnerDigest[]
  apiKeys                        ApiKey[]
  subscription                   OrgSubscription?
  branchBudgets                  BranchBudget[]
  forecastProfiles               ForecastProfile[]
  forecastPoints                 ForecastPoint[]
  franchiseRanks                 FranchiseRank[]
  franchiseBudgets               FranchiseBudget[] // E22-S3: Franchise budgets
  badgeAssets                    BadgeAsset[]
  kdsSlaConfigs                  KdsSlaConfig[] // M1-KDS: SLA configuration per station
  shiftTemplates                 ShiftTemplate[] // M2-SHIFTS: Shift templates
  reportSubscriptions            ReportSubscription[] // M4: Report subscriptions
  serviceProviders               ServiceProvider[] // M7: Service providers
  serviceReminders               ServicePayableReminder[] // M7: Payable reminders
  opsBudgets                     OpsBudget[] // M7: Operations budgets
  costInsights                   CostInsight[] // M7: Cost-cutting insights
  sessions                       Session[] // M10: Auth sessions
  documents                      Document[] // M18: Document storage
  staffAwards                    StaffAward[] // M19: Staff awards
  Feedback                       Feedback[]
  promotionSuggestions           PromotionSuggestion[] // M22: Promotion suggestions
  waitlistEntries                WaitlistEntry[] // M9.1: Waitlist
  reservationPolicies            ReservationPolicy[] // M9.2: Reservation policies
  webhookEndpoints               WebhookEndpoint[] // M9.5: Webhook endpoints
  notificationTemplates          NotificationTemplate[] // M9.5: Notification templates
  notificationOutbox             NotificationOutbox[] // M9.5: Notification outbox
  branchOperatingHours           BranchOperatingHours[] // M9.6: Operating hours
  branchBlackouts                BranchBlackout[] // M9.6: Blackout windows
  branchCapacityRules            BranchCapacityRule[] // M9.6: Capacity rules
  opsIncidents                   OpsIncident[] // M9.6: Ops incidents
  scheduledShifts                ScheduledShift[] // M10.1: Scheduled shifts
  workforceAuditLogs             WorkforceAuditLog[] // M10.1: Audit logs
  workforcePolicy                WorkforcePolicy? // M10.3: Workforce policy
  payPeriods                     PayPeriod[] // M10.3: Pay periods
  timesheetApprovals             TimesheetApproval[] // M10.3: Timesheet approvals
  timeEntryAdjustments           TimeEntryAdjustment[] // M10.5: Time entry adjustments
  payrollRuns                    PayrollRun[] // M10.6: Payroll runs
  compensationComponents         CompensationComponent[] // M10.7: Compensation components
  employeeCompensationProfiles   EmployeeCompensationProfile[] // M10.7: Employee compensation profiles
  payslips                       Payslip[] // M10.7: Payslips
  payrollPostingMappings         PayrollPostingMapping[] // M10.8: Payroll posting mappings
  remittanceBatches              RemittanceBatch[] // M10.9: Remittance batches
  remittanceProviders            RemittanceProvider[] // M10.10: Remittance providers
  compensationRemittanceMappings CompensationRemittanceMapping[] // M10.10: Component mappings
  // M10.11: Availability + Swaps + Open Shifts
  workforceAvailability          WorkforceAvailability[]
  availabilityExceptions         WorkforceAvailabilityException[]
  shiftSwapRequests              ShiftSwapRequest[]
  openShiftClaims                OpenShiftClaim[]
  workforceNotifications         WorkforceNotificationLog[]
  // M10.12: Labor Forecasting + Staffing Planner
  laborTargets                   LaborTarget[]
  laborForecastSnapshots         LaborForecastSnapshot[]
  staffingPlans                  StaffingPlan[]
  staffingAlerts                 StaffingAlert[]
  // M10.13: Auto-Scheduler
  autoScheduleRuns               AutoScheduleRun[]
  // M10.20: Geo-Fencing
  branchGeoFences                BranchGeoFence[]
  geoFenceEvents                 GeoFenceEvent[]
  // M10.21: Kiosk Devices
  kioskDevices                   KioskDevice[]
  kioskPinAttempts               KioskPinAttempt[]
  kioskClockEvents               KioskClockEvent[]
  // M10.22: Kiosk Events
  kioskEvents                    KioskEvent[]
  // M11.4: Recipes
  recipes                        Recipe[]
  // M11.5: Cost Layers
  costLayers                     InventoryCostLayer[]
  // M11.7: Lots
  inventoryLots                  InventoryLot[]
  // M11.8: Vendor Returns + Recalls
  vendorReturns                  VendorReturn[]
  recallCases                    RecallCase[]
  // M11.9: Production Batches
  productionBatches              ProductionBatch[]
  // M11.11: Barcodes
  itemBarcodes                   InventoryItemBarcode[]
  lotBarcodes                    InventoryLotBarcode[]
  // M11.12: Inventory Alerts
  inventoryAlerts                InventoryAlert[]
  // M12.1: Inventory Periods
  inventoryPeriods               InventoryPeriod[]
  // M12.2: Inventory Period Events
  inventoryPeriodEvents          InventoryPeriodEvent[]
  // M12.4: Inventory Period Close Requests
  inventoryPeriodCloseRequests   InventoryPeriodCloseRequest[]
  // M13.1: Menu Foundation
  categories                     Category[]
  menuItems                      MenuItem[]
  menuAvailabilityRules          MenuAvailabilityRule[]
  // M80: Prep Items
  prepItems                      PrepItem[]

  @@map("orgs")
}

model OrgSettings {
  id                        String   @id @default(cuid())
  orgId                     String   @unique
  vatPercent                Decimal  @default(18.00) @db.Decimal(5, 2)
  currency                  String   @default("UGX")
  discountApprovalThreshold Decimal  @default(5000) @db.Decimal(10, 2)
  reservationHoldMinutes    Int      @default(30)
  receiptFooter             String?
  metadata                  Json?
  anomalyThresholds         Json? // { lateVoidMin: 5, heavyDiscountUGX: 5000, noDrinksWarnRate: 0.25 }
  platformAccess            Json? // { "ROLE_NAME": { "desktop": bool, "web": bool, "mobile": bool }, ... }
  franchiseWeights          Json? // { revenue: 0.4, margin: 0.3, waste: -0.2, sla: 0.1 }
  showCostToChef            Boolean  @default(false)
  defaults                  Json? // Accounting defaults: { coaVersion: "v1", lockBackdate: false }
  baseCurrencyCode          String? // E39-s1: Base currency for accounting (falls back to currency field)
  taxMatrix                 Json? // E39-s1: { defaultTax: {code:"VAT_STD", rate:0.18, inclusive:true}, alcohol: {rate:0.15}, serviceCharge: {rate:0.1, inclusive:false} }
  rounding                  Json? // E39-s1: { cashRounding:"NEAREST_50", taxRounding:"HALF_UP" }
  bookingPolicies           Json? // E42-s1: { holdMinutes:30, allowPartial:true, creditExpiryHours:12 }
  attendance                Json? // E43-s1: { autoClockInOnMsr:true, overtimeAfterMinutes:480, hardCapAbsences:3 }
  inventoryTolerance        Json? // E45-s1: { pct: 0.05, absolute: 0 } - variance tolerance for stock counts
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  org Org @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@map("org_settings")
}

model Branch {
  id                   String   @id @default(cuid())
  orgId                String
  name                 String
  address              String?
  timezone             String   @default("Africa/Kampala")
  currencyCode         String? // E39-s1: Branch-specific currency (falls back to org base)
  publicBookingEnabled Boolean  @default(false) // M9.4: Public booking enabled
  publicBookingSlug    String?  @unique // M9.4: URL slug for public booking
  depletionLocationId  String? // M11.4: Default location for POS depletion
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  org                      Org                       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  depletionLocation        InventoryLocation?        @relation("BranchDepletionLocation", fields: [depletionLocationId], references: [id], onDelete: SetNull)
  tables                   Table[]
  orders                   Order[]
  auditEvents              AuditEvent[]
  menuItems                MenuItem[]
  categories               Category[]
  users                    User[]
  devices                  Device[]
  shifts                   Shift[]
  tillSessions             TillSession[]
  stockBatches             StockBatch[]
  purchaseOrders           PurchaseOrder[]
  goodsReceipts            GoodsReceipt[]
  wastageRecords           Wastage[]
  anomalyEvents            AnomalyEvent[]
  reservations             Reservation[]
  spoutDevices             SpoutDevice[]
  spoutEvents              SpoutEvent[]
  adjustments              Adjustment[]
  branchBudgets            BranchBudget[]
  forecastProfiles         ForecastProfile[]
  forecastPoints           ForecastPoint[]
  franchiseRanks           FranchiseRank[]
  franchiseBudgets         FranchiseBudget[] // E22-S3: Franchise budgets
  shiftSchedules           ShiftSchedule[] // M2-SHIFTS: Shift schedules
  stockMovements           StockMovement[] // M3: All stock movements at this branch
  reportSubscriptions      ReportSubscription[] // M4: Report subscriptions
  serviceProviders         ServiceProvider[] // M7: Service providers
  serviceContracts         ServiceContract[] // M7: Service contracts
  serviceReminders         ServicePayableReminder[] // M7: Payable reminders
  opsBudgets               OpsBudget[] // M7: Operations budgets
  costInsights             CostInsight[] // M7: Cost-cutting insights
  sessions                 Session[] // M10: Auth sessions
  documents                Document[] // M18: Document storage
  staffAwards              StaffAward[] // M19: Staff awards
  Feedback                 Feedback[]
  promotionSuggestions     PromotionSuggestion[] // M22: Promotion suggestions
  waitlistEntries          WaitlistEntry[] // M9.1: Waitlist
  reservationPolicy        ReservationPolicy? // M9.2: Branch policy
  webhookEndpoints         WebhookEndpoint[] // M9.5: Webhook endpoints
  notificationTemplates    NotificationTemplate[] // M9.5: Notification templates
  calendarFeedTokens       CalendarFeedToken[] // M9.5: Calendar feed tokens
  operatingHours           BranchOperatingHours[] // M9.6: Operating hours
  blackouts                BranchBlackout[] // M9.6: Blackout windows
  capacityRule             BranchCapacityRule? // M9.6: Capacity rules
  opsIncidents             OpsIncident[] // M9.6: Ops incidents
  scheduledShifts          ScheduledShift[]          @relation("ScheduledShifts") // M10.1: Scheduled shifts
  shiftTemplates           ShiftTemplate[] // M10.1: Branch-level shift templates
  payPeriods               PayPeriod[] // M10.3: Pay periods
  payrollRuns              PayrollRun[] // M10.6: Payroll runs
  compensationComponents   CompensationComponent[] // M10.7: Branch compensation overrides
  payrollPostingMappings   PayrollPostingMapping[] // M10.8: Branch payroll posting mappings
  remittanceBatches        RemittanceBatch[] // M10.9: Branch remittance batches
  remittanceProviders      RemittanceProvider[] // M10.10: Branch remittance providers
  shiftSwapRequests        ShiftSwapRequest[] // M10.11: Shift swap requests
  // M10.12: Labor Forecasting + Staffing Planner
  laborTargets             LaborTarget[]
  laborForecastSnapshots   LaborForecastSnapshot[]
  staffingPlans            StaffingPlan[]
  staffingAlerts           StaffingAlert[]
  // M10.13: Auto-Scheduler
  autoScheduleRuns         AutoScheduleRun[]
  // M10.20: Geo-fence
  geoFence                 BranchGeoFence?
  geoFenceEvents           GeoFenceEvent[]
  // M10.21: Kiosk Devices
  kioskDevices             KioskDevice[]
  kioskPinAttempts         KioskPinAttempt[]
  kioskClockEvents         KioskClockEvent[]
  // M10.22: Kiosk Events
  kioskEvents              KioskEvent[]
  // M11.1: Inventory Foundation
  inventoryLocations       InventoryLocation[]
  inventoryLedgerEntries   InventoryLedgerEntry[]
  stockAdjustments         StockAdjustment[]
  countSessions            CountSession[]
  // M11.2: Purchasing & Receiving
  purchaseOrdersV2         PurchaseOrderV2[]         @relation("BranchPurchaseOrdersV2")
  goodsReceiptsV2          GoodsReceiptV2[]          @relation("BranchGoodsReceiptsV2")
  // M11.3: Transfers + Waste
  transfersFrom            InventoryTransfer[]       @relation("TransferFromBranch")
  transfersTo              InventoryTransfer[]       @relation("TransferToBranch")
  wasteDocuments           InventoryWaste[]          @relation("WasteBranch")
  // M11.4: Depletions
  inventoryDepletions      OrderInventoryDepletion[] @relation("DepletionBranch")
  // M11.5: Cost Layers
  costLayers               InventoryCostLayer[]      @relation("CostLayerBranch")
  // M11.6: Reorder Automation
  reorderPolicies          ReorderPolicy[]           @relation("BranchReorderPolicies")
  reorderRuns              ReorderSuggestionRun[]    @relation("BranchReorderRuns")
  // M11.7: Lots
  inventoryLots            InventoryLot[]            @relation("LotBranch")
  // M11.8: Vendor Returns + Recalls
  vendorReturns            VendorReturn[]            @relation("VendorReturnBranch")
  recallCases              RecallCase[]              @relation("RecallCaseBranch")
  // M11.9: Production Batches
  productionBatches        ProductionBatch[]         @relation("ProductionBatchBranch")
  // M11.10: Stocktake Sessions v2
  stocktakeSessions        StocktakeSession[]        @relation("StocktakeSessionBranch")
  // M11.12: Inventory Alerts
  inventoryAlerts          InventoryAlert[]
  // M11.13: Inventory Posting Mappings
  inventoryPostingMappings InventoryPostingMapping[] @relation("InventoryPostingMappingBranch")
  // M11.14: Demand Forecasting + Reorder Optimization
  forecastSnapshots        DemandForecastSnapshot[]  @relation("BranchForecastSnapshots")
  optimizationRuns         ForecastOptimizationRun[] @relation("BranchOptimizationRuns")
  // M12.1: Inventory Periods
  inventoryPeriods         InventoryPeriod[]         @relation("InventoryPeriodBranch")
  // M12.2: Inventory Period Events
  inventoryPeriodEvents    InventoryPeriodEvent[]
  // M12.4: Inventory Period Close Requests
  inventoryPeriodCloseRequests InventoryPeriodCloseRequest[]
  // M13.1: Menu Availability Rules
  menuAvailabilityRules        MenuAvailabilityRule[]
  // M80: Prep Items
  prepItems                    PrepItem[]

  @@index([orgId, id])
  @@map("branches")
}

// ===== Users & Authentication =====

model User {
  id             String    @id @default(cuid())
  orgId          String
  branchId       String?
  email          String    @unique
  passwordHash   String?
  pinHash        String?
  firstName      String
  lastName       String
  roleLevel      RoleLevel @default(L1)
  jobRole        JobRole? // M8.1: Job role for role-specific UX (nullable for backward compatibility)
  isActive       Boolean   @default(true)
  sessionVersion Int       @default(0) // E25: Incremented on badge revocation to invalidate old JWTs
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  org                             Org                              @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch                          Branch?                          @relation(fields: [branchId], references: [id], onDelete: SetNull)
  roles                           Role[]
  orders                          Order[]
  auditEvents                     AuditEvent[]
  employeeProfile                 EmployeeProfile?
  sessions                        Session[]
  openedShifts                    Shift[]                          @relation("ShiftOpenedBy")
  closedShifts                    Shift[]                          @relation("ShiftClosedBy")
  openedTillSessions              TillSession[]                    @relation("TillSessionOpenedBy")
  closedTillSessions              TillSession[]                    @relation("TillSessionClosedBy")
  cashMovements                   CashMovement[]                   @relation("CashMovementCreatedBy")
  discounts                       Discount[]                       @relation("DiscountCreatedBy")
  approvedDiscounts               Discount[]                       @relation("DiscountApprovedBy")
  createdRefunds                  Refund[]                         @relation("CreatedRefunds")
  approvedRefunds                 Refund[]                         @relation("ApprovedRefunds")
  webAuthnCredentials             WebAuthnCredential[]
  anomalyEvents                   AnomalyEvent[]
  supportSessions                 SupportSession[]
  assignedBadges                  BadgeAsset[]
  procurementJobs                 ProcurementJob[]
  approvedPromotions              Promotion[]                      @relation("PromotionApprovals")
  leaveRequests                   LegacyLeaveRequest[] // Legacy leave requests
  approvedLeaves                  LegacyLeaveRequest[]             @relation("ApprovedLeave")
  leaveRequestsV2                 LeaveRequestV2[]                 @relation("LeaveRequestsV2") // M10.17
  approvedLeavesV2                LeaveRequestV2[]                 @relation("ApprovedLeaveV2") // M10.17
  approvedLeavesStep1             LeaveRequestV2[]                 @relation("ApprovedLeaveStep1") // M10.18
  leaveBalanceLedger              LeaveBalanceLedger[] // M10.17
  leaveAttachmentsAdded           LeaveRequestAttachment[]         @relation("LeaveAttachmentAddedBy") // M10.18
  delegatingApprovals             ApprovalDelegate[]               @relation("DelegatingUser") // M10.18
  delegatedApprovals              ApprovalDelegate[]               @relation("DelegateUser") // M10.18
  dutyShifts                      DutyShift[]
  assignedDutyShifts              DutyShift[]                      @relation("AssignedShifts")
  swapsFrom                       ShiftSwap[]                      @relation("SwapFrom")
  swapsTo                         ShiftSwap[]                      @relation("SwapTo")
  approvedSwaps                   ShiftSwap[]                      @relation("ApprovedSwaps")
  timeEntries                     TimeEntry[]
  approvedTimeEntries             TimeEntry[]                      @relation("ApprovedTimeEntries")
  stockCounts                     StockCount[] // E45-s1: Stock counts performed by user
  paySlips                        PaySlip[] // E43-s2: Payslips for user
  approvedPaySlips                PaySlip[]                        @relation("ApprovedPaySlips") // E43-s2: Payslips approved by user
  createdFlags                    FeatureFlag[]                    @relation("CreatedFlags") // E49-s1: Feature flags created by user
  updatedFlags                    FeatureFlag[]                    @relation("UpdatedFlags") // E49-s1: Feature flags updated by user
  createdMaintenanceWindows       MaintenanceWindow[]              @relation("CreatedMaintenanceWindows") // E49-s1: Maintenance windows created by user
  flagAudits                      FlagAudit[] // E49-s1: Flag audit trail
  shiftAssignments                ShiftAssignment[] // M2-SHIFTS: Shift assignments
  overriddenShifts                Shift[]                          @relation("ShiftOverrideBy") // M2-SHIFTS: Shifts overridden by manager
  reportedWastage                 Wastage[]                        @relation("WastageReportedBy") // M3: Wastage reported by this user
  reportSubscriptions             ReportSubscription[] // M4: User-specific report subscriptions
  acknowledgedReminders           ServicePayableReminder[] // M7: Reminders acknowledged by this user
  employee                        Employee? // M9: Employee record for this user
  revokedSessions                 Session[]                        @relation("SessionRevokedBy") // M10: Sessions revoked by this user
  assignedMsrCards                MsrCard[]                        @relation("MsrCardAssignedBy") // M10: MSR cards assigned by this user
  revokedMsrCards                 MsrCard[]                        @relation("MsrCardRevokedBy") // M10: MSR cards revoked by this user
  uploadedDocuments               Document[]                       @relation("DocumentUploader") // M18: Documents uploaded by this user
  createdAwards                   StaffAward[]                     @relation("CreatedAwards") // M19: Staff awards created by this user
  feedbackSubmitted               Feedback[]                       @relation("UserFeedback") // M20: Feedback submitted by this user
  suggestionsCreated              PromotionSuggestion[]            @relation("SuggestionCreators") // M22: Promotion suggestions created by this user
  suggestionsDecided              PromotionSuggestion[]            @relation("SuggestionDecisions") // M22: Promotion suggestions decided by this user
  assignedScheduledShifts         ScheduledShift[]                 @relation("AssignedScheduledShifts") // M10.1: Scheduled shifts
  publishedScheduledShifts        ScheduledShift[]                 @relation("PublishedScheduledShifts") // M10.1: Published shifts
  approvedScheduledShifts         ScheduledShift[]                 @relation("ApprovedScheduledShifts") // M10.1: Approved shifts
  cancelledScheduledShifts        ScheduledShift[]                 @relation("CancelledScheduledShifts") // M10.1: Cancelled shifts
  workforceAuditLogs              WorkforceAuditLog[] // M10.1: Audit log entries
  closedPayPeriods                PayPeriod[]                      @relation("ClosedPayPeriods") // M10.3: Pay periods closed
  exportedPayPeriods              PayPeriod[]                      @relation("ExportedPayPeriods") // M10.3: Pay periods exported
  approvedTimesheets              TimesheetApproval[]              @relation("ApprovedTimesheets") // M10.3: Approved timesheets
  rejectedTimesheets              TimesheetApproval[]              @relation("RejectedTimesheets") // M10.3: Rejected timesheets
  requestedAdjustments            TimeEntryAdjustment[]            @relation("RequestedAdjustments") // M10.5: Adjustments requested
  approvedAdjustments             TimeEntryAdjustment[]            @relation("ApprovedAdjustments") // M10.5: Adjustments approved
  createdPayrollRuns              PayrollRun[]                     @relation("CreatedPayrollRuns") // M10.6: Created payroll runs
  approvedPayrollRuns             PayrollRun[]                     @relation("ApprovedPayrollRuns") // M10.6: Approved payroll runs
  postedPayrollRuns               PayrollRun[]                     @relation("PostedPayrollRuns") // M10.6: Posted payroll runs
  paidPayrollRuns                 PayrollRun[]                     @relation("PaidPayrollRuns") // M10.6: Paid payroll runs
  voidedPayrollRuns               PayrollRun[]                     @relation("VoidedPayrollRuns") // M10.6: Voided payroll runs
  payrollRunLines                 PayrollRunLine[] // M10.6: Payroll run lines
  compensationProfiles            EmployeeCompensationProfile[] // M10.7: Compensation profiles
  payslips                        Payslip[] // M10.7: Payslips
  createdRemittanceBatches        RemittanceBatch[]                @relation("CreatedRemittanceBatches") // M10.9
  approvedRemittanceBatches       RemittanceBatch[]                @relation("ApprovedRemittanceBatches") // M10.9
  postedRemittanceBatches         RemittanceBatch[]                @relation("PostedRemittanceBatches") // M10.9
  paidRemittanceBatches           RemittanceBatch[]                @relation("PaidRemittanceBatches") // M10.9
  voidedRemittanceBatches         RemittanceBatch[]                @relation("VoidedRemittanceBatches") // M10.9
  // M10.11: Availability + Swaps + Open Shifts
  workforceAvailability           WorkforceAvailability[]
  availabilityExceptions          WorkforceAvailabilityException[]
  swapRequestsAsRequester         ShiftSwapRequest[]               @relation("SwapRequester")
  swapRequestsAsTarget            ShiftSwapRequest[]               @relation("SwapTarget")
  swapRequestsAsClaimer           ShiftSwapRequest[]               @relation("SwapClaimer")
  swapRequestsApproved            ShiftSwapRequest[]               @relation("SwapApprover")
  swapRequestsRejected            ShiftSwapRequest[]               @relation("SwapRejecter")
  openShiftClaims                 OpenShiftClaim[]                 @relation("ShiftClaimant")
  approvedOpenShiftClaims         OpenShiftClaim[]                 @relation("ClaimApprover")
  rejectedOpenShiftClaims         OpenShiftClaim[]                 @relation("ClaimRejecter")
  workforceNotificationsReceived  WorkforceNotificationLog[]       @relation("NotificationTarget")
  workforceNotificationsPerformed WorkforceNotificationLog[]       @relation("NotificationPerformer")
  // M10.12: Labor Forecasting + Staffing Planner
  publishedStaffingPlans          StaffingPlan[]                   @relation("PlanPublisher")
  resolvedStaffingAlerts          StaffingAlert[]                  @relation("AlertResolver")
  // M10.13: Auto-Scheduler
  appliedAutoScheduleRuns         AutoScheduleRun[]                @relation("RunApplier")
  // M10.14: Auto-Scheduler v2 (Publish + Assignment)
  publishedAutoScheduleRuns       AutoScheduleRun[]                @relation("RunPublisher")
  assignedScheduleSuggestions     AutoScheduleSuggestion[]         @relation("SuggestionAssignee")
  // M10.19: Compliance Incidents
  complianceIncidents             OpsIncident[]                    @relation("ComplianceIncidents")
  // M10.20: Geo-Fencing
  clockInOverridesGiven           TimeEntry[]                      @relation("ClockInOverrideBy")
  clockOutOverridesGiven          TimeEntry[]                      @relation("ClockOutOverrideBy")
  createdGeoFences                BranchGeoFence[]                 @relation("GeoFenceCreatedBy")
  updatedGeoFences                BranchGeoFence[]                 @relation("GeoFenceUpdatedBy")
  geoFenceEvents                  GeoFenceEvent[]                  @relation("GeoFenceEventUser")
  geoFenceEventOverrides          GeoFenceEvent[]                  @relation("GeoFenceEventOverrideBy")
  // M10.21: Kiosk Devices
  createdKioskDevices             KioskDevice[]                    @relation("KioskDeviceCreatedBy")
  kioskPinAttempts                KioskPinAttempt[]                @relation("KioskPinAttemptUser")
  kioskClockEvents                KioskClockEvent[]                @relation("KioskClockEventUser")
  // M10.22: Kiosk Events
  kioskEvents                     KioskEvent[]                     @relation("KioskEventUser")
  // M11.1: Inventory Foundation
  ledgerEntriesCreated            InventoryLedgerEntry[]           @relation("LedgerEntryCreator")
  stockAdjustmentsCreated         StockAdjustment[]                @relation("StockAdjustmentCreator")
  stockAdjustmentsApproved        StockAdjustment[]                @relation("StockAdjustmentApprover")
  countSessionsCreated            CountSession[]                   @relation("CountSessionCreator")
  countSessionsFinalized          CountSession[]                   @relation("CountSessionFinalizer")
  countSessionLinesCounted        CountSessionLine[]               @relation("CountSessionLineCounter")
  // M11.2: Purchasing & Receiving
  purchaseOrdersCreated           PurchaseOrderV2[]                @relation("POCreator")
  purchaseOrdersApproved          PurchaseOrderV2[]                @relation("POApprover")
  receiptsPosted                  GoodsReceiptV2[]                 @relation("ReceiptPostedBy")
  // M11.3: Transfers + Waste
  transfersCreated                InventoryTransfer[]              @relation("TransferCreator")
  transfersShipped                InventoryTransfer[]              @relation("TransferShipper")
  transfersReceived               InventoryTransfer[]              @relation("TransferReceiver")
  wasteCreated                    InventoryWaste[]                 @relation("WasteCreator")
  wastePosted                     InventoryWaste[]                 @relation("WastePoster")
  // M11.4: Recipes
  recipesCreated                  Recipe[]                         @relation("RecipeCreator")
  recipesUpdated                  Recipe[]                         @relation("RecipeUpdater")
  // M11.5: Costing + Valuation + COGS
  costLayersCreated               InventoryCostLayer[]             @relation("CostLayerCreator")
  // M11.6: Reorder Automation
  reorderRunsCreated              ReorderSuggestionRun[]           @relation("ReorderRunCreator")
  // M11.7: Lots
  lotsCreated                     InventoryLot[]                   @relation("LotCreator")
  // M11.8: Vendor Returns + Recalls
  vendorReturnsCreated            VendorReturn[]                   @relation("VendorReturnCreator")
  vendorReturnsSubmitted          VendorReturn[]                   @relation("VendorReturnSubmitter")
  vendorReturnsPosted             VendorReturn[]                   @relation("VendorReturnPoster")
  vendorReturnsVoided             VendorReturn[]                   @relation("VendorReturnVoider")
  recallCasesCreated              RecallCase[]                     @relation("RecallCaseCreator")
  recallCasesClosed               RecallCase[]                     @relation("RecallCaseCloser")
  recallLotLinks                  RecallLotLink[]                  @relation("RecallLotLinker")
  // M11.9: Production Batches
  productionBatchesCreated        ProductionBatch[]                @relation("ProductionBatchCreator")
  productionBatchesProduced       ProductionBatch[]                @relation("ProductionBatchProducer")
  productionBatchesVoided         ProductionBatch[]                @relation("ProductionBatchVoider")
  // M11.10: Stocktake Sessions v2
  stocktakeSessionsCreated        StocktakeSession[]               @relation("StocktakeSessionCreator")
  stocktakeSessionsStarted        StocktakeSession[]               @relation("StocktakeSessionStarter")
  stocktakeSessionsSubmitted      StocktakeSession[]               @relation("StocktakeSessionSubmitter")
  stocktakeSessionsApproved       StocktakeSession[]               @relation("StocktakeSessionApprover")
  stocktakeSessionsPosted         StocktakeSession[]               @relation("StocktakeSessionPoster")
  stocktakeSessionsVoided         StocktakeSession[]               @relation("StocktakeSessionVoider")
  stocktakeLinesCounted           StocktakeLine[]                  @relation("StocktakeLineCounter")
  // M11.11: Barcodes
  itemBarcodesCreated             InventoryItemBarcode[]           @relation("BarcodeCreator")
  lotBarcodesCreated              InventoryLotBarcode[]            @relation("LotBarcodeCreator")
  // M11.12: Inventory Alerts
  alertsAcknowledged              InventoryAlert[]                 @relation("AlertAcknowledger")
  alertsResolved                  InventoryAlert[]                 @relation("AlertResolver")
  // M11.13: Inventory Posting Mappings
  inventoryPostingMappingsCreated InventoryPostingMapping[]        @relation("InventoryPostingMappingCreator")
  // M11.14: Demand Forecasting + Reorder Optimization
  forecastSnapshotsGenerated      DemandForecastSnapshot[]         @relation("ForecastSnapshotCreator")
  optimizationRunsCreated         ForecastOptimizationRun[]        @relation("OptimizationRunCreator")
  // M12.1: Inventory Periods
  inventoryPeriodsClosed          InventoryPeriod[]                @relation("InventoryPeriodCloser")
  // M12.2: Inventory Period Events
  inventoryPeriodEvents           InventoryPeriodEvent[]           @relation("PeriodEventActor")
  // M12.4: Inventory Period Close Requests
  closeRequestsCreated            InventoryPeriodCloseRequest[]    @relation("CloseRequestRequester")
  closeRequestsApproved           InventoryPeriodCloseRequest[]    @relation("CloseRequestApprover")
  // M13.4: POS Payments + Cash Sessions + Receipts
  cashSessionsOpened              CashSession[]                    @relation("CashSessionOpener")
  cashSessionsClosed              CashSession[]                    @relation("CashSessionCloser")
  receiptsIssued                  PosReceipt[]                     @relation("ReceiptIssuer")
  // M80: Prep Items
  prepItemsCreated                PrepItem[]

  @@index([orgId, id])
  @@map("users")
}

model EmployeeProfile {
  id           String   @id @default(cuid())
  userId       String   @unique
  employeeCode String   @unique
  badgeId      String?  @unique
  badgeCode    String? // Optional reference to BadgeAsset.code (soft link for legacy)
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("employee_profiles")
}

model BadgeAsset {
  id             String     @id @default(cuid())
  orgId          String
  code           String     @unique
  state          BadgeState @default(ACTIVE)
  assignedUserId String?
  lastUsedAt     DateTime?
  custody        Json? // Audit trail: [{ assignedTo, assignedAt, returnedAt }]
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  org          Org   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  assignedUser User? @relation(fields: [assignedUserId], references: [id], onDelete: SetNull)

  @@index([orgId])
  @@index([assignedUserId])
  @@map("badge_assets")
}

// M10: MSR Card Assignment Model
// Formal mapping of hashed card tokens to employees
// Separates logical card assignment from physical BadgeAsset tracking
enum MsrCardStatus {
  ACTIVE
  REVOKED
  SUSPENDED
}

model MsrCard {
  id            String        @id @default(cuid())
  orgId         String
  employeeId    String        @unique // One card per employee
  cardToken     String        @unique // SHA-256 hash of track data (never store raw)
  status        MsrCardStatus @default(ACTIVE)
  assignedAt    DateTime      @default(now())
  assignedById  String // Manager/HR who assigned
  revokedAt     DateTime?
  revokedById   String? // Who revoked
  revokedReason String? // Why revoked
  metadata      Json? // Additional info (physical badge ID reference, etc.)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  assignedBy User     @relation("MsrCardAssignedBy", fields: [assignedById], references: [id], onDelete: Restrict)
  revokedBy  User?    @relation("MsrCardRevokedBy", fields: [revokedById], references: [id], onDelete: SetNull)

  @@index([orgId])
  @@index([cardToken]) // Fast lookup during swipe
  @@index([employeeId])
  @@index([status])
  @@map("msr_cards")
}

model Device {
  id        String   @id @default(cuid())
  orgId     String
  branchId  String
  name      String
  deviceKey String   @unique
  isActive  Boolean  @default(true)
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org      Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch   Branch    @relation(fields: [branchId], references: [id], onDelete: Cascade)
  sessions Session[]

  @@index([orgId, id])
  @@map("devices")
}

// M10: Session lifecycle platforms
enum SessionPlatform {
  WEB_BACKOFFICE
  POS_DESKTOP
  MOBILE_APP
  KDS_SCREEN
  DEV_PORTAL
  OTHER
}

// M10: Session auth source
enum SessionSource {
  PASSWORD
  PIN
  MSR_CARD
  API_KEY
  SSO
  WEBAUTHN
}

model Session {
  id             String          @id @default(cuid())
  userId         String
  orgId          String // M10: Org for session queries
  branchId       String? // M10: Branch for session queries
  employeeId     String? // M10: Link to M9 Employee model
  deviceId       String?
  badgeId        String? // E25: Track badge for badge-based session invalidation
  token          String          @unique
  platform       SessionPlatform @default(OTHER) // M10: Client platform
  source         SessionSource   @default(PASSWORD) // M10: Auth method
  ipAddress      String? // M10: Client IP for audit
  userAgent      String? // M10: Client user agent
  lastActivityAt DateTime        @default(now()) // M10: For idle timeout
  expiresAt      DateTime
  revokedAt      DateTime? // M10: Manual revocation timestamp
  revokedById    String? // M10: Who revoked (admin/manager)
  revokedReason  String? // M10: Why revoked
  createdAt      DateTime        @default(now())

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  org       Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch    Branch?   @relation(fields: [branchId], references: [id], onDelete: SetNull)
  employee  Employee? @relation(fields: [employeeId], references: [id], onDelete: SetNull)
  device    Device?   @relation(fields: [deviceId], references: [id], onDelete: SetNull)
  revokedBy User?     @relation("SessionRevokedBy", fields: [revokedById], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([orgId])
  @@index([badgeId]) // E25: Index for efficient badge-based invalidation
  @@index([expiresAt])
  @@index([lastActivityAt]) // M10: For idle timeout queries
  @@index([revokedAt]) // M10: For active session queries
  @@map("sessions")
}

model WebAuthnCredential {
  id           String   @id @default(cuid())
  userId       String
  credentialId String   @unique // base64url encoded
  publicKey    Bytes
  counter      Int      @default(0)
  deviceType   String // "singleDevice" or "multiDevice"
  backedUp     Boolean  @default(false)
  transports   String[] // ["usb", "nfc", "ble", "internal"]
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("webauthn_credentials")
}

model FloorPlan {
  id        String   @id @default(cuid())
  orgId     String
  name      String
  data      Json
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org          Org           @relation(fields: [orgId], references: [id], onDelete: Cascade)
  tables       Table[]
  reservations Reservation[]

  @@index([orgId, id])
  @@map("floor_plans")
}

model Role {
  id          String   @id @default(cuid())
  name        String
  description String?
  level       Int      @default(1) // L1-L5
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users       User[]
  permissions Permission[]

  @@map("roles")
}

model Permission {
  id         String   @id @default(cuid())
  resource   String // e.g., "orders", "inventory", "reports"
  action     String // e.g., "read", "create", "update", "delete"
  conditions Json? // ABAC conditions
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  roles Role[]

  @@unique([resource, action])
  @@map("permissions")
}

// ===== Floor & Tables =====

model Table {
  id          String      @id @default(cuid())
  orgId       String
  branchId    String
  floorPlanId String?
  label       String
  capacity    Int         @default(4)
  status      TableStatus @default(AVAILABLE)
  isActive    Boolean     @default(true)
  metadata    Json? // floor plan position, shape, etc.
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  branch       Branch        @relation(fields: [branchId], references: [id], onDelete: Cascade)
  floorPlan    FloorPlan?    @relation(fields: [floorPlanId], references: [id], onDelete: SetNull)
  orders       Order[]
  reservations Reservation[]

  @@unique([branchId, label])
  @@index([orgId, id])
  @@map("tables")
}

model Reservation {
  id                 String            @id @default(cuid())
  orgId              String
  branchId           String
  floorPlanId        String?
  tableId            String?
  name               String
  phone              String?
  partySize          Int
  startAt            DateTime
  endAt              DateTime
  status             ReservationStatus @default(HELD)
  source             ReservationSource @default(PHONE)
  notes              String?
  cancellationReason String?
  deposit            Decimal           @default(0) @db.Decimal(10, 2)
  depositStatus      String            @default("NONE") // "NONE" | "HELD" | "CAPTURED" | "REFUNDED"
  paymentIntentId    String?
  reminderSentAt     DateTime?
  autoCancelAt       DateTime?
  seatedAt           DateTime?
  completedAt        DateTime?
  createdById        String?
  updatedById        String?
  cancelledById      String?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt

  org              Org                      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch           Branch                   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  floorPlan        FloorPlan?               @relation(fields: [floorPlanId], references: [id], onDelete: SetNull)
  table            Table?                   @relation(fields: [tableId], references: [id], onDelete: SetNull)
  paymentIntent    PaymentIntent?           @relation(fields: [paymentIntentId], references: [id], onDelete: SetNull)
  reminders        ReservationReminder[]
  documents        Document[]
  feedback         Feedback? // M20: Customer feedback for this reservation
  deposits         ReservationDeposit[] // M9.2: Deposit records
  notificationLogs NotificationLog[] // M9.2: Notification audit trail
  accessTokens     ReservationAccessToken[] // M9.4: Public access tokens

  @@index([orgId])
  @@index([branchId])
  @@index([tableId, startAt, endAt])
  @@index([autoCancelAt])
  @@index([status])
  @@map("reservations")
}

// M9.4: Public Booking Access Tokens
model ReservationAccessToken {
  id            String    @id @default(cuid())
  reservationId String
  token         String    @unique
  scope         String // "CANCEL" | "RESCHEDULE" | "VIEW" | "ALL"
  expiresAt     DateTime
  usedAt        DateTime?
  createdAt     DateTime  @default(now())

  reservation Reservation @relation(fields: [reservationId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([reservationId])
  @@map("reservation_access_tokens")
}

model ReservationReminder {
  id            String    @id @default(cuid())
  reservationId String
  channel       String // "SMS" | "EMAIL"
  target        String // phone number or email
  scheduledAt   DateTime
  sentAt        DateTime?
  createdAt     DateTime  @default(now())

  reservation Reservation @relation(fields: [reservationId], references: [id], onDelete: Cascade)

  @@index([scheduledAt, sentAt])
  @@map("reservation_reminders")
}

model WaitlistEntry {
  id                String         @id @default(cuid())
  orgId             String
  branchId          String
  name              String
  phone             String?
  partySize         Int
  notes             String?
  quotedWaitMinutes Int?
  status            WaitlistStatus @default(WAITING)
  addedById         String?
  seatedById        String?
  seatedAt          DateTime?
  droppedAt         DateTime?
  droppedReason     String?
  promotedToResId   String? // M9.3: Linked reservation ID if auto-promoted
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  org              Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch           Branch            @relation(fields: [branchId], references: [id], onDelete: Cascade)
  notificationLogs NotificationLog[] // M9.2: Notification audit trail

  @@index([orgId])
  @@index([branchId])
  @@index([status, createdAt])
  @@map("waitlist_entries")
}

// M9.2: Reservation Policy (per branch)
model ReservationPolicy {
  id                    String   @id @default(cuid())
  orgId                 String
  branchId              String   @unique
  leadTimeMinutes       Int      @default(60)
  maxPartySize          Int      @default(20)
  holdExpiresMinutes    Int      @default(30)
  cancelCutoffMinutes   Int      @default(120)
  depositRequired       Boolean  @default(false)
  depositAmountDefault  Decimal  @default(0) @db.Decimal(10, 2)
  depositPerGuest       Decimal  @default(0) @db.Decimal(10, 2)
  noShowFeeEnabled      Boolean  @default(false)
  noShowFeeAmount       Decimal  @default(0) @db.Decimal(10, 2)
  // M9.3: Automation fields
  autoExpireHeldEnabled Boolean  @default(true)
  waitlistAutoPromote   Boolean  @default(false)
  reminderEnabled       Boolean  @default(true)
  reminderLeadMinutes   Int      @default(1440) // 24 hours before
  maxCapacityPerSlot    Int? // null = unlimited
  noShowGraceMinutes    Int      @default(15)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  org    Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@map("reservation_policies")
}

// M9.2: Reservation Deposit
model ReservationDeposit {
  id              String         @id @default(cuid())
  orgId           String
  reservationId   String
  amount          Decimal        @db.Decimal(10, 2)
  status          DepositStatus  @default(REQUIRED)
  paymentMethod   PaymentMethod?
  journalEntryId  String?
  refundJournalId String?
  applyJournalId  String?
  paidAt          DateTime?
  refundedAt      DateTime?
  appliedAt       DateTime?
  refundReason    String?
  createdById     String?
  paidById        String?
  refundedById    String?
  appliedById     String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  reservation   Reservation   @relation(fields: [reservationId], references: [id], onDelete: Cascade)
  journalEntry  JournalEntry? @relation("DepositJournal", fields: [journalEntryId], references: [id])
  refundJournal JournalEntry? @relation("DepositRefundJournal", fields: [refundJournalId], references: [id])
  applyJournal  JournalEntry? @relation("DepositApplyJournal", fields: [applyJournalId], references: [id])

  @@index([orgId])
  @@index([reservationId])
  @@index([status])
  @@map("reservation_deposits")
}

// M9.2: Notification Log
model NotificationLog {
  id            String             @id @default(cuid())
  orgId         String
  branchId      String?
  reservationId String?
  waitlistId    String?
  type          NotificationType
  event         NotificationEvent
  toAddress     String?
  payloadJson   Json?
  status        NotificationStatus @default(QUEUED)
  sentAt        DateTime?
  failedReason  String?
  createdAt     DateTime           @default(now())

  reservation Reservation?   @relation(fields: [reservationId], references: [id], onDelete: SetNull)
  waitlist    WaitlistEntry? @relation(fields: [waitlistId], references: [id], onDelete: SetNull)

  @@index([orgId])
  @@index([branchId])
  @@index([reservationId])
  @@index([event, createdAt])
  @@map("notification_logs")
}

// M9.3: Automation Audit Log
model AutomationLog {
  id          String   @id @default(cuid())
  orgId       String
  branchId    String?
  action      String // e.g., "HOLD_EXPIRED", "WAITLIST_PROMOTED", "REMINDER_SCHEDULED"
  entityType  String // "Reservation" | "WaitlistEntry"
  entityId    String
  actorType   String   @default("SYSTEM") // "SYSTEM" or userId
  actorId     String? // null for SYSTEM
  beforeState Json?
  afterState  Json?
  metadata    Json?
  createdAt   DateTime @default(now())

  @@index([orgId])
  @@index([branchId])
  @@index([entityType, entityId])
  @@index([action, createdAt])
  @@map("automation_logs")
}

// ===== Menu =====

// M13.1: Selection type for modifier groups
enum ModifierSelectionType {
  SINGLE
  MULTI
}

// M13.1: Target type for availability rules
enum AvailabilityTargetType {
  CATEGORY
  ITEM
}

model Category {
  id               String     @id @default(cuid())
  orgId            String // M13.1: Org-scoped for cross-branch queries
  branchId         String
  name             String
  description      String? // M13.1: Optional description
  parentCategoryId String? // M13.1: Optional nesting
  sortOrder        Int        @default(0)
  isActive         Boolean    @default(true)
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  org            Org                    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch         Branch                 @relation(fields: [branchId], references: [id], onDelete: Cascade)
  parentCategory Category?              @relation("CategoryHierarchy", fields: [parentCategoryId], references: [id], onDelete: SetNull)
  childCategories Category[]            @relation("CategoryHierarchy")
  menuItems      MenuItem[]
  availabilityRules MenuAvailabilityRule[] @relation("CategoryAvailability")

  @@unique([orgId, branchId, name]) // M13.1: Unique name per org+branch
  @@index([branchId])
  @@index([orgId])
  @@map("categories")
}

model MenuItem {
  id             String     @id @default(cuid())
  orgId          String // M13.1: Org-scoped for cross-branch queries
  branchId       String
  categoryId     String?
  name           String
  description    String?
  sku            String? // M13.1: Optional SKU, unique per org
  itemType       ItemType
  station        StationTag @default(OTHER)
  price          Decimal    @db.Decimal(10, 2)
  basePriceCents Int? // M13.1: Price in cents for precision (optional migration)
  taxCategoryId  String?
  isAvailable    Boolean    @default(true)
  isActive       Boolean    @default(true) // M13.1: Soft delete
  trackInventory Boolean    @default(false) // M13.1: Bridge to M11 recipes
  sortOrder      Int        @default(0) // M13.1: Stable ordering
  metadata       Json? // variations, etc.
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  org               Org                      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch            Branch                   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  category          Category?                @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  taxCategory       TaxCategory?             @relation(fields: [taxCategoryId], references: [id], onDelete: SetNull)
  orderItems        OrderItem[]
  modifierGroups    MenuItemOnGroup[]
  recipeIngredients RecipeIngredient[]
  availabilityRules MenuAvailabilityRule[]   @relation("ItemAvailability")

  @@unique([orgId, sku]) // M13.1: SKU unique per org (if present)
  @@index([branchId])
  @@index([orgId])
  @@map("menu_items")
}

model TaxCategory {
  id           String   @id @default(cuid())
  orgId        String
  name         String
  rate         Decimal  @db.Decimal(5, 2)
  efirsTaxCode String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  org       Org        @relation(fields: [orgId], references: [id], onDelete: Cascade)
  menuItems MenuItem[]

  @@map("tax_categories")
}

model ModifierGroup {
  id            String                 @id @default(cuid())
  orgId         String
  name          String
  description   String? // M13.1: Optional description
  selectionType ModifierSelectionType  @default(SINGLE) // M13.1: Selection type
  min           Int                    @default(0)
  max           Int                    @default(0)
  required      Boolean                @default(false)
  sortOrder     Int                    @default(0) // M13.1: Stable ordering
  isActive      Boolean                @default(true) // M13.1: Soft delete
  createdAt     DateTime               @default(now())
  updatedAt     DateTime               @updatedAt

  org       Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)
  options   ModifierOption[]
  menuItems MenuItemOnGroup[]

  @@index([orgId])
  @@map("modifier_groups")
}

model ModifierOption {
  id         String   @id @default(cuid())
  groupId    String
  name       String
  priceDelta Decimal  @db.Decimal(10, 2)
  sortOrder  Int      @default(0) // M13.1: Stable ordering
  isActive   Boolean  @default(true) // M13.1: Soft delete
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  group             ModifierGroup      @relation(fields: [groupId], references: [id], onDelete: Cascade)
  recipeIngredients RecipeIngredient[]

  @@index([groupId])
  @@map("modifier_options")
}

model MenuItemOnGroup {
  id        String @id @default(cuid())
  itemId    String
  groupId   String
  sortOrder Int    @default(0) // M13.1: Ordering of groups on item

  item  MenuItem      @relation(fields: [itemId], references: [id], onDelete: Cascade)
  group ModifierGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([itemId, groupId])
  @@map("menu_item_on_group")
}

// M13.1: Menu Availability Rules
model MenuAvailabilityRule {
  id         String                 @id @default(cuid())
  orgId      String
  branchId   String? // null = all branches
  targetType AvailabilityTargetType
  categoryId String? // When targetType = CATEGORY
  itemId     String? // When targetType = ITEM
  daysOfWeek Int[]                  @default([0, 1, 2, 3, 4, 5, 6]) // 0=Sun, 6=Sat
  startTime  String                 @default("00:00") // HH:MM format
  endTime    String                 @default("23:59") // HH:MM format
  isActive   Boolean                @default(true)
  createdAt  DateTime               @default(now())
  updatedAt  DateTime               @updatedAt

  org      Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch   Branch?   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  category Category? @relation("CategoryAvailability", fields: [categoryId], references: [id], onDelete: Cascade)
  item     MenuItem? @relation("ItemAvailability", fields: [itemId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([branchId])
  @@index([targetType, categoryId])
  @@index([targetType, itemId])
  @@map("menu_availability_rules")
}

// ===== Orders =====

model Order {
  id            String             @id @default(cuid())
  branchId      String
  tableId       String?
  userId        String
  orderNumber   String
  status        OrderStatus        @default(NEW)
  paymentStatus OrderPaymentStatus @default(UNPAID) // M13.5: Payment settlement state
  serviceType   ServiceType        @default(DINE_IN)
  subtotal     Decimal     @default(0) @db.Decimal(12, 2)
  tax          Decimal     @default(0) @db.Decimal(12, 2)
  discount     Decimal     @default(0) @db.Decimal(10, 2)
  total        Decimal     @default(0) @db.Decimal(12, 2)
  anomalyFlags String[]
  metadata     Json?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  branch             Branch                   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  table              Table?                   @relation(fields: [tableId], references: [id], onDelete: SetNull)
  user               User                     @relation(fields: [userId], references: [id], onDelete: Restrict)
  orderItems         OrderItem[]
  payments           Payment[]
  refunds            Refund[]
  kdsTickets         KdsTicket[]
  discounts          Discount[]
  stockMovements     StockMovement[] // M3: Stock movements from this order
  Feedback           Feedback?
  inventoryDepletion OrderInventoryDepletion? // M11.4: POS depletion record

  @@unique([branchId, orderNumber])
  @@index([branchId])
  @@index([updatedAt]) // E54-s1: For sorting/filtering by update time
  @@index([status, updatedAt]) // E54-s1: For status-based queries with sorting
  @@map("orders")
}

model KdsTicket {
  id             String     @id @default(cuid())
  orderId        String
  station        StationTag
  status         String     @default("QUEUED") // QUEUED|IN_PROGRESS|READY|DONE|VOID
  createdAt      DateTime   @default(now())
  sentAt         DateTime   @default(now()) // M1-KDS: When order was sent to kitchen/bar
  startedAt      DateTime? // M13.3: When ticket moved to IN_PROGRESS
  readyAt        DateTime?
  doneAt         DateTime? // M13.3: When ticket completed
  voidedAt       DateTime? // M13.3: When voided
  voidReason     String? // M13.3: Required for void
  idempotencyKey String? // M13.3: For safe regeneration (orderId+station)
  updatedAt      DateTime   @updatedAt // M1-KDS: For polling/sync with "since" parameter

  order Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  lines KdsTicketLine[] // M13.3: Per-item tracking

  @@unique([orderId, station]) // M13.3: Idempotency - one ticket per station per order
  @@index([station, status, sentAt]) // M1-KDS: Efficient filtering and ordering
  @@map("kds_tickets")
}

// M13.3: Per-item tracking on KDS tickets
model KdsTicketLine {
  id                String   @id @default(cuid())
  ticketId          String
  orderItemId       String
  itemNameSnapshot  String // From OrderItem.itemNameSnapshot (M13.2)
  qty               Int
  modifiersSnapshot Json? // From OrderItem.selectedModifiersSnapshot (M13.2)
  notesSnapshot     String?
  status            String   @default("NEW") // NEW|IN_PROGRESS|READY|DONE|VOID
  bumpedAt          DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  ticket    KdsTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  orderItem OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@map("kds_ticket_lines")
}

// M1-KDS: SLA configuration for KDS colour coding
model KdsSlaConfig {
  id                 String     @id @default(cuid())
  orgId              String
  station            StationTag
  greenThresholdSec  Int        @default(300) // 5 minutes - green if under
  orangeThresholdSec Int        @default(600) // 10 minutes - orange if under, red if over
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt

  org Org @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([orgId, station])
  @@map("kds_sla_configs")
}

// M2-SHIFTS: Shift template for recurring shift patterns
model ShiftTemplate {
  id           String   @id @default(cuid())
  orgId        String
  branchId     String? // M10.1: null = org-wide template
  name         String // e.g. "Lunch Service", "Dinner Service"
  role         String? // M10.1: jobRole slug
  startTime    String // Time of day, e.g. "11:00"
  endTime      String // Time of day, e.g. "16:00"
  breakMinutes Int? // M10.1: default break duration
  description  String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  org       Org             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch    Branch?         @relation(fields: [branchId], references: [id], onDelete: Cascade)
  schedules ShiftSchedule[]

  @@index([orgId])
  @@index([branchId])
  @@map("shift_templates")
}

// M2-SHIFTS: Daily shift schedule based on template
model ShiftSchedule {
  id         String   @id @default(cuid())
  orgId      String
  branchId   String
  date       DateTime @db.Date // Specific date for this schedule
  templateId String? // Optional link to template
  startTime  DateTime // Actual start time (can override template)
  endTime    DateTime // Actual end time (can override template)
  notes      String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  branch      Branch            @relation(fields: [branchId], references: [id], onDelete: Cascade)
  template    ShiftTemplate?    @relation(fields: [templateId], references: [id], onDelete: SetNull)
  assignments ShiftAssignment[]

  @@unique([branchId, date, startTime]) // Prevent duplicate schedules
  @@index([branchId, date])
  @@map("shift_schedules")
}

// M2-SHIFTS: Staff assignment to specific scheduled shift
model ShiftAssignment {
  id              String   @id @default(cuid())
  scheduleId      String
  userId          String
  role            String // e.g. "WAITER", "MANAGER", "CHEF", "BARTENDER"
  isManagerOnDuty Boolean  @default(false) // Flag for primary manager
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  schedule ShiftSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  user     User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([scheduleId, userId]) // One assignment per user per schedule
  @@index([scheduleId])
  @@index([userId])
  @@map("shift_assignments")
}

model Shift {
  id             String    @id @default(cuid())
  orgId          String
  branchId       String
  openedById     String
  closedById     String?
  openedAt       DateTime  @default(now())
  closedAt       DateTime?
  openingFloat   Decimal   @default(0) @db.Decimal(10, 2)
  declaredCash   Decimal?  @db.Decimal(10, 2)
  overShort      Decimal?  @db.Decimal(10, 2)
  notes          String?
  metadata       Json?
  // M2-SHIFTS: Manager override for out-of-tolerance stock counts
  overrideUserId String? // Manager who approved override
  overrideReason String? // Reason for override
  overrideAt     DateTime? // When override was applied

  branch         Branch          @relation(fields: [branchId], references: [id], onDelete: Cascade)
  openedBy       User            @relation("ShiftOpenedBy", fields: [openedById], references: [id], onDelete: Restrict)
  closedBy       User?           @relation("ShiftClosedBy", fields: [closedById], references: [id], onDelete: Restrict)
  overrideBy     User?           @relation("ShiftOverrideBy", fields: [overrideUserId], references: [id], onDelete: Restrict)
  tillSessions   TillSession[]
  stockCounts    StockCount[] // E45-s1: Stock counts for this shift
  wastage        Wastage[] // M3: Wastage recorded during this shift
  stockMovements StockMovement[] // M3: All stock movements during shift

  @@index([branchId, openedAt])
  @@map("shifts")
}

// E45-s1: Stock count gate at shift close
model StockCount {
  id          String   @id @default(cuid())
  orgId       String
  branchId    String
  shiftId     String
  countedAt   DateTime @default(now())
  countedById String
  notes       String?
  lines       Json // [{ itemId, countedQty }]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  shift     Shift @relation(fields: [shiftId], references: [id], onDelete: Cascade)
  countedBy User  @relation(fields: [countedById], references: [id], onDelete: Restrict)

  @@index([orgId, branchId, countedAt])
  @@index([shiftId])
  @@map("stock_counts")
}

model TillSession {
  id           String    @id @default(cuid())
  orgId        String
  branchId     String
  drawerId     String // Identifier for cash drawer (e.g., "DRAWER-1", "REGISTER-A")
  openedById   String
  closedById   String?
  openingFloat Decimal   @db.Decimal(10, 2)
  closingCount Decimal?  @db.Decimal(10, 2) // Total cash counted at close
  variance     Decimal?  @db.Decimal(10, 2) // Difference between expected and counted
  openedAt     DateTime  @default(now())
  closedAt     DateTime?
  shiftId      String? // Optional link to shift
  metadata     Json?

  branch        Branch         @relation(fields: [branchId], references: [id], onDelete: Cascade)
  openedBy      User           @relation("TillSessionOpenedBy", fields: [openedById], references: [id], onDelete: Restrict)
  closedBy      User?          @relation("TillSessionClosedBy", fields: [closedById], references: [id], onDelete: Restrict)
  shift         Shift?         @relation(fields: [shiftId], references: [id], onDelete: SetNull)
  cashMovements CashMovement[]

  @@index([orgId, branchId])
  @@index([branchId, drawerId, closedAt])
  @@map("till_sessions")
}

model CashMovement {
  id            String           @id @default(cuid())
  orgId         String
  branchId      String
  tillSessionId String
  type          CashMovementType
  amount        Decimal          @db.Decimal(10, 2)
  reason        String?
  createdById   String
  createdAt     DateTime         @default(now())
  metadata      Json?

  tillSession TillSession @relation(fields: [tillSessionId], references: [id], onDelete: Cascade)
  createdBy   User        @relation("CashMovementCreatedBy", fields: [createdById], references: [id], onDelete: Restrict)

  @@index([tillSessionId])
  @@index([orgId, branchId, createdAt])
  @@map("cash_movements")
}

model Discount {
  id           String   @id @default(cuid())
  orgId        String
  orderId      String
  createdById  String
  type         String // percentage, fixed
  value        Decimal  @db.Decimal(10, 2)
  approvedById String?
  createdAt    DateTime @default(now())
  metadata     Json?

  order      Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  createdBy  User  @relation("DiscountCreatedBy", fields: [createdById], references: [id], onDelete: Restrict)
  approvedBy User? @relation("DiscountApprovedBy", fields: [approvedById], references: [id], onDelete: Restrict)

  @@index([orderId])
  @@map("discounts")
}

model OrderItem {
  id          String   @id @default(cuid())
  orderId     String
  menuItemId  String
  quantity    Int      @default(1)
  price       Decimal  @db.Decimal(10, 2)
  subtotal    Decimal  @db.Decimal(10, 2)
  notes       String?
  metadata    Json? // modifiers, special instructions
  costUnit    Decimal? @db.Decimal(10, 2) // UGX cost per unit
  costTotal   Decimal? @db.Decimal(10, 2)
  marginTotal Decimal? @db.Decimal(10, 2)
  marginPct   Decimal? @db.Decimal(5, 2) // percentage

  // M13.2: Pricing Snapshot Fields (immutable after creation)
  itemNameSnapshot         String?  // Snapshot of item name at order time
  basePriceCentsSnapshot   Int?     // Snapshot of item base price in cents
  selectedModifiersSnapshot Json?   // [{groupName, optionName, priceDelta}]
  unitPriceCentsSnapshot   Int?     // base + modifier deltas
  lineTotalCentsSnapshot   Int?     // unitPrice * quantity

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  order          Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
  menuItem       MenuItem        @relation(fields: [menuItemId], references: [id], onDelete: Restrict)
  kdsTicketLines KdsTicketLine[] // M13.3: Reverse relation for ticket lines

  @@map("order_items")
}

// ===== Payments =====

model Payment {
  id            String              @id @default(cuid())
  orgId         String?             // M13.4: Required for org scoping (nullable for legacy data)
  branchId      String?             // M13.4: Required for branch scoping (nullable for legacy data)
  orderId       String
  amount        Decimal             @db.Decimal(10, 2)
  amountCents   Int                 @default(0) // M13.4: Integer cents for precision
  capturedCents Int                 @default(0) // M13.4: Amount captured
  refundedCents Int                 @default(0) // M13.4: Amount refunded
  tipCents      Int                 @default(0) // M13.5: Tip amount (NOT counted in dueCents)
  currency      String              @default("USD") // M13.4: Currency code
  method        PaymentMethod
  posStatus     PosPaymentStatus    @default(PENDING) // M13.4: Lifecycle status
  provider      PosPaymentProvider  @default(INTERNAL) // M13.4: Provider
  providerRef   String?             // M13.4: External reference (auth id, etc)
  status        String              @default("pending") // Legacy: pending, completed, failed, refunded
  transactionId String?
  idempotencyKey String?            // M13.4: Idempotency key
  metadata      Json?
  createdById   String?             // M13.4: User who created
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  order   Order            @relation(fields: [orderId], references: [id], onDelete: Cascade)
  refunds Refund[]
  events  PosPaymentEvent[] // M13.4: Audit trail

  @@unique([orgId, idempotencyKey]) // M13.4: Idempotency scoped to org
  @@index([orderId]) // E54-s1: For payment lookup by order
  @@index([status, createdAt]) // E54-s1: For payment status queries
  @@index([orgId, branchId, posStatus]) // M13.4: For org/branch queries
  @@map("payments")
}

// M13.4: Payment event audit trail (append-only)
model PosPaymentEvent {
  id          String   @id @default(cuid())
  orgId       String
  paymentId   String
  type        String   // CREATED | AUTHORIZED | CAPTURED | VOIDED | REFUNDED | FAILED
  metadata    Json     @default("{}")
  createdById String
  createdAt   DateTime @default(now())

  payment Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([paymentId])
  @@index([orgId, type])
  @@map("pos_payment_events")
}

model Refund {
  id           String   @id @default(cuid())
  orderId      String
  paymentId    String
  provider     String // "MOMO" | "CASH" | "CARD" | "MANUAL"
  amount       Decimal  @db.Decimal(10, 2)
  reason       String
  status       String   @default("PENDING") // "PENDING" | "COMPLETED" | "FAILED"
  createdById  String
  approvedById String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  order      Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  payment    Payment @relation(fields: [paymentId], references: [id])
  createdBy  User    @relation("CreatedRefunds", fields: [createdById], references: [id])
  approvedBy User?   @relation("ApprovedRefunds", fields: [approvedById], references: [id])

  @@index([orderId])
  @@index([status, createdAt])
  @@map("refunds")
}

// M13.4: Cash drawer session for accountability
model CashSession {
  id                String            @id @default(cuid())
  orgId             String
  branchId          String
  openedById        String
  openedAt          DateTime          @default(now())
  closedById        String?
  closedAt          DateTime?
  openingFloatCents Int
  expectedCashCents Int?
  countedCashCents  Int?
  status            CashSessionStatus @default(OPEN)
  note              String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  openedBy User  @relation("CashSessionOpener", fields: [openedById], references: [id])
  closedBy User? @relation("CashSessionCloser", fields: [closedById], references: [id])

  @@index([orgId, branchId, status])
  @@index([branchId, status]) // M13.4: For checking open session
  @@map("cash_sessions")
}

// M13.4: POS receipt for paid orders
model PosReceipt {
  id             String   @id @default(cuid())
  orgId          String
  branchId       String
  orderId        String
  receiptNumber  String
  issuedAt       DateTime @default(now())
  issuedById     String
  totalsSnapshot Json

  issuedBy User @relation("ReceiptIssuer", fields: [issuedById], references: [id])

  @@unique([orgId, receiptNumber])
  @@unique([orgId, orderId]) // M13.4: One receipt per order
  @@index([orgId, branchId])
  @@map("pos_receipts")
}

model PaymentIntent {
  id          String   @id @default(cuid())
  orgId       String
  branchId    String
  orderId     String
  provider    String // "MTN" | "AIRTEL" | "MOMO"
  amount      Decimal  @db.Decimal(12, 2)
  currency    String   @default("UGX")
  status      String   @default("PENDING") // "PENDING" | "REQUIRES_ACTION" | "SUCCEEDED" | "FAILED" | "CANCELLED"
  providerRef String?
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  reservations Reservation[]

  @@index([orgId, orderId])
  @@index([status, createdAt])
  @@map("payment_intents")
}

model WebhookEvent {
  id         String   @id @default(cuid())
  provider   String // "MTN" | "AIRTEL"
  eventType  String
  raw        Json
  verified   Boolean  @default(false)
  receivedAt DateTime @default(now())

  @@index([provider, receivedAt])
  @@map("webhook_events")
}

model FiscalInvoice {
  id          String     @id @default(cuid())
  orgId       String
  branchId    String
  orderId     String     @unique
  status      String     @default("PENDING") // PENDING | SENT | FAILED
  efirsTin    String?
  deviceCode  String?
  response    Json?
  attempts    Int        @default(0)
  lastTriedAt DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  documents   Document[]

  @@index([orgId, status])
  @@index([status, lastTriedAt])
  @@map("fiscal_invoices")
}

// ===== Audit & Compliance =====

model AuditEvent {
  id         String   @id @default(cuid())
  branchId   String
  userId     String?
  action     String // e.g., "order.created", "order.voided", "payment.completed"
  resource   String // table name
  resourceId String? // record ID
  before     Json?
  after      Json?
  metadata   Json?
  createdAt  DateTime @default(now())

  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)
  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([branchId, createdAt])
  @@index([userId])
  @@index([action])
  @@map("audit_events")
}

model AnomalyEvent {
  id         String   @id @default(cuid())
  orgId      String
  branchId   String?
  userId     String?
  orderId    String?
  type       String // NO_DRINKS | LATE_VOID | HEAVY_DISCOUNT | VOID_SPIKE
  severity   String   @default("INFO") // INFO | WARN | CRITICAL
  details    Json?
  occurredAt DateTime @default(now())

  org    Org     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch? @relation(fields: [branchId], references: [id], onDelete: Cascade)
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([orgId, occurredAt])
  @@index([branchId, type])
  @@index([userId])
  @@index([occurredAt]) // E54-s1: For time-based queries
  @@map("anomaly_events")
}

model AlertChannel {
  id      String  @id @default(cuid())
  orgId   String
  type    String // EMAIL | SLACK
  target  String // email address or webhook URL
  enabled Boolean @default(true)

  org Org @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@map("alert_channels")
}

model ScheduledAlert {
  id        String    @id @default(cuid())
  orgId     String
  name      String
  cron      String
  rule      String // VOID_SPIKE | LATE_VOID | HEAVY_DISCOUNT | NO_DRINKS_RATE
  enabled   Boolean   @default(true)
  lastRunAt DateTime?

  org Org @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@map("scheduled_alerts")
}

model SupportSession {
  id          String   @id @default(cuid())
  orgId       String
  createdById String
  token       String   @unique
  expiresAt   DateTime
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  org       Org  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  createdBy User @relation(fields: [createdById], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([token])
  @@index([expiresAt])
  @@map("support_sessions")
}

model ApiKey {
  id         String    @id @default(cuid())
  orgId      String
  name       String
  keyHash    String    @unique
  scopes     String[]
  lastUsedAt DateTime?
  createdAt  DateTime  @default(now())

  org Org @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@map("api_keys")
}

// M18: Document & Receipt Management

model Document {
  id              String           @id @default(cuid())
  orgId           String
  branchId        String?
  category        DocumentCategory
  fileName        String
  mimeType        String
  sizeBytes       Int
  storageProvider StorageProvider  @default(LOCAL)
  storageKey      String           @unique
  checksum        String?
  uploadedById    String
  uploadedAt      DateTime         @default(now())
  tags            String[]         @default([])
  notes           String?
  deletedAt       DateTime?

  serviceProviderId String?
  purchaseOrderId   String?
  goodsReceiptId    String?
  stockBatchId      String?
  payRunId          String?
  paySlipId         String?
  reservationId     String?
  eventBookingId    String?
  bankStatementId   String?
  employeeId        String?
  fiscalInvoiceId   String?

  org             Org              @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch          Branch?          @relation(fields: [branchId], references: [id], onDelete: SetNull)
  uploader        User             @relation("DocumentUploader", fields: [uploadedById], references: [id], onDelete: Restrict)
  serviceProvider ServiceProvider? @relation(fields: [serviceProviderId], references: [id], onDelete: SetNull)
  purchaseOrder   PurchaseOrder?   @relation(fields: [purchaseOrderId], references: [id], onDelete: SetNull)
  goodsReceipt    GoodsReceipt?    @relation(fields: [goodsReceiptId], references: [id], onDelete: SetNull)
  stockBatch      StockBatch?      @relation(fields: [stockBatchId], references: [id], onDelete: SetNull)
  payRun          PayRun?          @relation(fields: [payRunId], references: [id], onDelete: SetNull)
  paySlip         PaySlip?         @relation(fields: [paySlipId], references: [id], onDelete: SetNull)
  reservation     Reservation?     @relation(fields: [reservationId], references: [id], onDelete: SetNull)
  eventBooking    EventBooking?    @relation(fields: [eventBookingId], references: [id], onDelete: SetNull)
  bankStatement   BankStatement?   @relation(fields: [bankStatementId], references: [id], onDelete: SetNull)
  employee        Employee?        @relation(fields: [employeeId], references: [id], onDelete: SetNull)
  fiscalInvoice   FiscalInvoice?   @relation(fields: [fiscalInvoiceId], references: [id], onDelete: SetNull)

  @@index([orgId])
  @@index([orgId, category])
  @@index([orgId, uploadedAt])
  @@index([branchId])
  @@index([serviceProviderId])
  @@index([purchaseOrderId])
  @@index([goodsReceiptId])
  @@index([stockBatchId])
  @@index([payRunId])
  @@index([paySlipId])
  @@index([reservationId])
  @@index([eventBookingId])
  @@index([bankStatementId])
  @@index([employeeId])
  @@index([fiscalInvoiceId])
  @@index([deletedAt])
  @@map("documents")
}

// ===== Hardware Integrations =====

model SpoutDevice {
  id        String   @id @default(cuid())
  orgId     String
  branchId  String
  name      String
  vendor    String // POURSENSE | FLOWX | SANDBOX
  secret    String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org          Org                @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch       Branch             @relation(fields: [branchId], references: [id], onDelete: Cascade)
  calibrations SpoutCalibration[]
  events       SpoutEvent[]

  @@index([orgId])
  @@index([branchId])
  @@map("spout_devices")
}

model SpoutCalibration {
  id              String   @id @default(cuid())
  deviceId        String
  inventoryItemId String
  mlPerPulse      Decimal  @db.Decimal(8, 4)
  createdAt       DateTime @default(now())

  device        SpoutDevice   @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  inventoryItem InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  @@unique([deviceId, inventoryItemId])
  @@index([deviceId])
  @@map("spout_calibrations")
}

model SpoutEvent {
  id         String   @id @default(cuid())
  orgId      String
  branchId   String
  deviceId   String
  itemId     String?
  pulses     Int
  ml         Decimal  @db.Decimal(10, 3)
  raw        Json?
  occurredAt DateTime
  ingestedAt DateTime @default(now())

  org    Org         @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch      @relation(fields: [branchId], references: [id], onDelete: Cascade)
  device SpoutDevice @relation(fields: [deviceId], references: [id], onDelete: Cascade)

  @@index([occurredAt])
  @@index([deviceId])
  @@index([orgId, branchId])
  @@map("spout_events")
}

model OwnerDigest {
  id               String    @id @default(cuid())
  orgId            String
  name             String
  cron             String // e.g., "0 8 * * *" for daily at 8am
  lastRunAt        DateTime?
  recipients       String[] // Array of email addresses
  sendOnShiftClose Boolean   @default(false)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  org Org @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@map("owner_digests")
}

// M4: Enhanced Report Subscriptions
model ReportSubscription {
  id              String    @id @default(cuid())
  orgId           String
  branchId        String? // Optional: null = org-level
  reportType      String // SHIFT_END, DAILY_SUMMARY, WEEKLY_SUMMARY, MONTHLY_SUMMARY, FRANCHISE_WEEKLY
  deliveryChannel String    @default("EMAIL") // EMAIL, SLACK
  recipientType   String // USER, ROLE
  recipientId     String? // userId if recipientType=USER, role code if ROLE
  recipientEmail  String? // Override email if needed
  enabled         Boolean   @default(true)
  includeCSVs     Boolean   @default(true)
  includePDF      Boolean   @default(true)
  metadata        Json? // Additional config (e.g., sections to include)
  lastRunAt       DateTime? // M4: Track when digest last ran
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  org    Org     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch? @relation(fields: [branchId], references: [id], onDelete: Cascade)
  user   User?   @relation(fields: [recipientId], references: [id], onDelete: Cascade) // M4: User recipient

  @@index([orgId])
  @@index([branchId])
  @@index([reportType])
  @@map("report_subscriptions")
}

// ===== Inventory & Purchasing =====

model Supplier {
  id           String   @id @default(cuid())
  orgId        String
  name         String
  contact      String?
  email        String?
  phone        String?
  leadTimeDays Int      @default(2)
  minOrderQty  Decimal? @db.Decimal(10, 3)
  packSize     Decimal? @db.Decimal(10, 3)
  isActive     Boolean  @default(true)
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  purchaseOrders PurchaseOrder[]

  @@index([orgId])
  @@map("suppliers")
}

model InventoryItem {
  id           String   @id @default(cuid())
  orgId        String
  sku          String?
  name         String
  unit         String // kg, ltr, pcs, etc. (legacy - prefer uomId)
  uomId        String? // M11.1: Reference to UnitOfMeasure
  category     String?
  reorderLevel Decimal  @default(0) @db.Decimal(10, 3)
  reorderQty   Decimal  @default(0) @db.Decimal(10, 3)
  isActive     Boolean  @default(true)
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  uom                    UnitOfMeasure?             @relation("ItemUom", fields: [uomId], references: [id], onDelete: SetNull)
  stockBatches           StockBatch[]
  recipeIngredients      RecipeIngredient[]
  wastageRecords         Wastage[]
  adjustments            Adjustment[]
  poItems                PurchaseOrderItem[]
  receiptLines           GoodsReceiptLine[]
  spoutCalibrations      SpoutCalibration[]
  forecastProfiles       ForecastProfile[]
  forecastPoints         ForecastPoint[]
  stockMovements         StockMovement[] // M3: Track all inventory movements
  lowStockConfigs        LowStockConfig[] // M3: Low-stock alert configuration
  ledgerEntries          InventoryLedgerEntry[] // M11.1: Ledger entries
  stockAdjustments       StockAdjustment[]          @relation("StockAdjustmentItem") // M11.1: Stock adjustments
  countSessionLines      CountSessionLine[]         @relation("CountSessionLineItem") // M11.1: Count lines
  // M11.2: Purchasing & Receiving
  poLinesV2              PurchaseOrderLineV2[]      @relation("POLineItem")
  receiptLinesV2         GoodsReceiptLineV2[]       @relation("ReceiptLineItem")
  // M11.3: Transfers + Waste
  transferLines          InventoryTransferLine[]    @relation("TransferLineItem")
  wasteLines             InventoryWasteLine[]       @relation("WasteLineItem")
  // M11.4: Recipes
  recipeLines            RecipeLine[]               @relation("RecipeLineItem")
  // M11.5: Costing
  costLayers             InventoryCostLayer[]       @relation("CostLayerItem")
  depletionCosts         DepletionCostBreakdown[]   @relation("DepletionCostItem")
  // M11.6: Supplier Catalog + Reorder
  supplierItems          SupplierItem[]             @relation("ItemSupplierItems")
  reorderPolicies        ReorderPolicy[]            @relation("ItemReorderPolicies")
  reorderSuggestions     ReorderSuggestionLine[]    @relation("ItemReorderSuggestions")
  // M11.7: Lots + Expiry + Traceability
  lots                   InventoryLot[]             @relation("LotItem")
  // M11.8: Vendor Return Lines
  vendorReturnLines      VendorReturnLine[]         @relation("VendorReturnLineItem")
  // M11.9: Production Batches
  productionBatchOutputs ProductionBatch[]          @relation("ProductionBatchOutputItem")
  productionBatchLines   ProductionBatchLine[]      @relation("ProductionLineItem")
  // M11.10: Stocktake Lines v2
  stocktakeLines         StocktakeLine[]            @relation("StocktakeLineItem")
  // M11.11: Barcodes
  barcodes               InventoryItemBarcode[]     @relation("ItemBarcodes")
  // M11.14: Demand Forecasting + Reorder Optimization
  forecastSnapshots      DemandForecastSnapshot[]   @relation("ItemForecastSnapshots")
  optimizationLines      ForecastOptimizationLine[] @relation("ItemOptimizationLines")
  // M12.1: Period Snapshots + Movement Summaries
  valuationSnapshots     InventoryValuationSnapshot[]        @relation("ValuationSnapshotItem")
  movementSummaries      InventoryPeriodMovementSummary[]    @relation("MovementSummaryItem")
  // M80: Prep Items
  prepLines              PrepLine[]                          @relation("PrepLineItem")
  prepItemOutputs        PrepItem[]                          @relation("PrepItemOutput")

  @@unique([orgId, sku])
  @@index([orgId])
  @@index([orgId, isActive]) // M11.15: Filtered active item lists
  @@map("inventory_items")
}

model StockBatch {
  id             String    @id @default(cuid())
  orgId          String
  branchId       String
  itemId         String
  batchNumber    String?
  receivedQty    Decimal   @db.Decimal(10, 3)
  remainingQty   Decimal   @db.Decimal(10, 3)
  unitCost       Decimal   @db.Decimal(10, 2)
  expiryDate     DateTime?
  receivedAt     DateTime  @default(now())
  goodsReceiptId String?
  metadata       Json?

  branch         Branch          @relation(fields: [branchId], references: [id], onDelete: Cascade)
  item           InventoryItem   @relation(fields: [itemId], references: [id], onDelete: Restrict)
  goodsReceipt   GoodsReceipt?   @relation(fields: [goodsReceiptId], references: [id], onDelete: SetNull)
  stockMovements StockMovement[] // M3: Movements from this batch
  documents      Document[]

  @@index([orgId, itemId])
  @@index([branchId, receivedAt])
  @@map("stock_batches")
}

model PurchaseOrder {
  id          String    @id @default(cuid())
  orgId       String
  branchId    String
  supplierId  String
  poNumber    String
  status      String    @default("draft") // draft, placed, received, cancelled
  totalAmount Decimal   @default(0) @db.Decimal(12, 2)
  placedAt    DateTime?
  metadata    Json?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  branch        Branch              @relation(fields: [branchId], references: [id], onDelete: Cascade)
  supplier      Supplier            @relation(fields: [supplierId], references: [id], onDelete: Restrict)
  items         PurchaseOrderItem[]
  goodsReceipts GoodsReceipt[]
  documents     Document[]

  @@unique([orgId, poNumber])
  @@index([orgId, branchId])
  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id        String   @id @default(cuid())
  poId      String
  itemId    String
  qty       Decimal  @db.Decimal(10, 3)
  unitCost  Decimal  @db.Decimal(10, 2)
  subtotal  Decimal  @db.Decimal(12, 2)
  createdAt DateTime @default(now())

  po   PurchaseOrder @relation(fields: [poId], references: [id], onDelete: Cascade)
  item InventoryItem @relation(fields: [itemId], references: [id], onDelete: Restrict)

  @@map("purchase_order_items")
}

model ProcurementJob {
  id           String               @id @default(cuid())
  orgId        String
  createdById  String
  period       String?              @db.VarChar(7) // YYYY-MM
  strategy     ProcurementStrategy
  draftPoCount Int                  @default(0)
  status       ProcurementJobStatus @default(DRAFT)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  createdBy User @relation(fields: [createdById], references: [id], onDelete: Restrict)

  @@index([orgId])
  @@index([orgId, status])
  @@map("procurement_jobs")
}

model Promotion {
  id               String    @id @default(cuid())
  orgId            String
  name             String
  code             String? // Optional coupon code
  active           Boolean   @default(false)
  startsAt         DateTime?
  endsAt           DateTime?
  scope            Json? // {branches: [...], categories: [...], items: [...]}
  daypart          Json? // {days: [1..7], start: "HH:mm", end: "HH:mm"}
  priority         Int       @default(100)
  exclusive        Boolean   @default(false)
  requiresApproval Boolean   @default(true)
  approvedById     String?
  approvedAt       DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  approvedBy User?             @relation("PromotionApprovals", fields: [approvedById], references: [id], onDelete: SetNull)
  effects    PromotionEffect[]

  @@index([orgId])
  @@index([orgId, active])
  @@index([code])
  @@map("promotions")
}

model PromotionEffect {
  id          String              @id @default(cuid())
  promotionId String
  type        PromotionEffectType
  value       Decimal?            @db.Decimal(10, 2) // Percentage or fixed amount
  meta        Json? // Additional config (bundle items, etc.)
  createdAt   DateTime            @default(now())

  promotion Promotion @relation(fields: [promotionId], references: [id], onDelete: Cascade)

  @@map("promotion_effects")
}

model GoodsReceipt {
  id         String   @id @default(cuid())
  orgId      String
  branchId   String
  poId       String?
  grNumber   String
  receivedAt DateTime @default(now())
  receivedBy String?
  metadata   Json?
  createdAt  DateTime @default(now())

  branch       Branch             @relation(fields: [branchId], references: [id], onDelete: Cascade)
  po           PurchaseOrder?     @relation(fields: [poId], references: [id], onDelete: SetNull)
  lines        GoodsReceiptLine[]
  stockBatches StockBatch[]
  documents    Document[]

  @@unique([orgId, grNumber])
  @@index([orgId, branchId])
  @@map("goods_receipts")
}

model GoodsReceiptLine {
  id          String    @id @default(cuid())
  grId        String
  itemId      String
  qtyReceived Decimal   @db.Decimal(10, 3)
  unitCost    Decimal   @db.Decimal(10, 2)
  batchNumber String?
  expiryDate  DateTime?
  createdAt   DateTime  @default(now())

  gr   GoodsReceipt  @relation(fields: [grId], references: [id], onDelete: Cascade)
  item InventoryItem @relation(fields: [itemId], references: [id], onDelete: Restrict)

  @@map("goods_receipt_lines")
}

model RecipeIngredient {
  id               String   @id @default(cuid())
  menuItemId       String
  itemId           String
  qtyPerUnit       Decimal  @db.Decimal(10, 3) // qty of ingredient per menu item
  wastePct         Decimal  @default(0) @db.Decimal(5, 2)
  modifierOptionId String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  menuItem       MenuItem        @relation(fields: [menuItemId], references: [id], onDelete: Cascade)
  item           InventoryItem   @relation(fields: [itemId], references: [id], onDelete: Restrict)
  modifierOption ModifierOption? @relation(fields: [modifierOptionId], references: [id], onDelete: SetNull)

  @@index([menuItemId])
  @@index([itemId])
  @@map("recipe_ingredients")
}

model Wastage {
  id         String   @id @default(cuid())
  orgId      String
  branchId   String
  itemId     String
  shiftId    String? // M3: Link wastage to shift
  userId     String? // M3: User who reported wastage
  qty        Decimal  @db.Decimal(10, 3)
  reason     String?
  reportedBy String? // Deprecated: use userId
  metadata   Json?
  createdAt  DateTime @default(now())

  branch Branch        @relation(fields: [branchId], references: [id], onDelete: Cascade)
  item   InventoryItem @relation(fields: [itemId], references: [id], onDelete: Restrict)
  shift  Shift?        @relation(fields: [shiftId], references: [id], onDelete: SetNull)
  user   User?         @relation("WastageReportedBy", fields: [userId], references: [id], onDelete: SetNull)

  @@index([orgId, branchId])
  @@index([itemId])
  @@index([shiftId])
  @@map("wastage")
}

model Adjustment {
  id         String   @id @default(cuid())
  orgId      String
  branchId   String
  itemId     String
  deltaQty   Decimal  @db.Decimal(10, 3) // Positive = add, Negative = remove
  reason     String
  adjustedBy String
  metadata   Json?
  createdAt  DateTime @default(now())

  branch Branch        @relation(fields: [branchId], references: [id], onDelete: Cascade)
  item   InventoryItem @relation(fields: [itemId], references: [id], onDelete: Restrict)

  @@index([orgId, branchId])
  @@index([itemId])
  @@map("adjustments")
}

// M3: Stock movements for ingredient-level accuracy and reconciliation
model StockMovement {
  id        String   @id @default(cuid())
  orgId     String
  branchId  String
  itemId    String
  shiftId   String? // Link to shift when movement occurred
  orderId   String? // Link to order if from sale
  batchId   String? // Link to batch affected (for FIFO tracking)
  type      String // SALE, WASTAGE, ADJUSTMENT, PURCHASE, COUNT_ADJUSTMENT
  qty       Decimal  @db.Decimal(10, 3) // Positive = add, Negative = deduct
  cost      Decimal  @db.Decimal(10, 2) // Cost impact (for COGS tracking)
  reason    String? // For wastage/adjustments
  metadata  Json? // Additional context
  createdAt DateTime @default(now())

  branch Branch        @relation(fields: [branchId], references: [id], onDelete: Cascade)
  item   InventoryItem @relation(fields: [itemId], references: [id], onDelete: Restrict)
  shift  Shift?        @relation(fields: [shiftId], references: [id], onDelete: SetNull)
  order  Order?        @relation(fields: [orderId], references: [id], onDelete: SetNull)
  batch  StockBatch?   @relation(fields: [batchId], references: [id], onDelete: SetNull)

  @@index([orgId, branchId, createdAt])
  @@index([itemId])
  @@index([shiftId])
  @@index([orderId])
  @@map("stock_movements")
}

// M3: Low-stock alert configuration
model LowStockConfig {
  id             String   @id @default(cuid())
  orgId          String
  branchId       String? // null = org-level default
  itemId         String? // null = category-level config
  category       String? // Applies to all items in category if itemId is null
  minQuantity    Decimal? @db.Decimal(10, 3) // Alert when stock falls below this
  minDaysOfCover Int? // Alert when estimated days of stock remaining < this
  alertLevel     String   @default("LOW") // LOW, CRITICAL
  enabled        Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  item InventoryItem? @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([orgId, branchId, itemId, category])
  @@index([orgId])
  @@index([branchId])
  @@index([itemId])
  @@map("low_stock_configs")
}

// ===== E24: Subscriptions & Dev Portal =====

model DevAdmin {
  id        String   @id @default(cuid())
  email     String   @unique
  isSuper   Boolean  @default(false)
  createdAt DateTime @default(now())

  @@map("dev_admins")
}

model SubscriptionPlan {
  id       String  @id @default(cuid())
  code     String  @unique
  name     String
  priceUGX Decimal @db.Decimal(10, 2)
  features Json
  isActive Boolean @default(true)

  subscriptions OrgSubscription[]

  @@map("subscription_plans")
}

model OrgSubscription {
  id            String             @id @default(cuid())
  orgId         String
  planId        String
  status        SubscriptionStatus @default(ACTIVE)
  nextRenewalAt DateTime
  graceUntil    DateTime?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  org  Org              @relation(fields: [orgId], references: [id], onDelete: Cascade)
  plan SubscriptionPlan @relation(fields: [planId], references: [id], onDelete: Restrict)

  @@unique([orgId])
  @@index([status, nextRenewalAt])
  @@map("org_subscriptions")
}

model SubscriptionEvent {
  id    String                @id @default(cuid())
  orgId String
  type  SubscriptionEventType
  meta  Json
  at    DateTime              @default(now())

  @@index([orgId, at])
  @@map("subscription_events")
}

// ===== E22: Franchise Models =====

enum ForecastMethod {
  MA7
  MA14
  MA30
}

model BranchBudget {
  id            String   @id @default(cuid())
  orgId         String
  branchId      String
  period        String   @db.VarChar(7) // YYYY-MM
  revenueTarget Decimal  @db.Decimal(12, 2)
  cogsTarget    Decimal  @db.Decimal(12, 2)
  expenseTarget Decimal  @db.Decimal(12, 2)
  notes         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  org    Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@unique([orgId, branchId, period])
  @@index([orgId, period])
  @@map("branch_budgets")
}

model ForecastProfile {
  id                String         @id @default(cuid())
  orgId             String
  branchId          String?
  itemId            String?
  method            ForecastMethod @default(MA14)
  weekendUpliftPct  Decimal        @default(0) @db.Decimal(5, 2)
  monthEndUpliftPct Decimal        @default(0) @db.Decimal(5, 2)
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  org    Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch?        @relation(fields: [branchId], references: [id], onDelete: Cascade)
  item   InventoryItem? @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@index([orgId, branchId])
  @@index([orgId, itemId])
  @@map("forecast_profiles")
}

model ForecastPoint {
  id           String   @id @default(cuid())
  orgId        String
  branchId     String
  itemId       String
  date         DateTime @db.Date
  predictedQty Decimal  @db.Decimal(10, 2)
  createdAt    DateTime @default(now())

  org    Org           @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch        @relation(fields: [branchId], references: [id], onDelete: Cascade)
  item   InventoryItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([orgId, branchId, itemId, date])
  @@index([orgId, date])
  @@map("forecast_points")
}

model FranchiseRank {
  id        String   @id @default(cuid())
  orgId     String
  period    String   @db.VarChar(7) // YYYY-MM
  branchId  String
  score     Decimal  @db.Decimal(10, 2)
  rank      Int
  meta      Json
  createdAt DateTime @default(now())

  org    Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@unique([orgId, period, branchId])
  @@index([orgId, period, rank])
  @@map("franchise_ranks")
}

// E22-S3: Franchise budgets (monthly, per branch, per category)
model FranchiseBudget {
  id           String   @id @default(cuid())
  orgId        String
  branchId     String
  year         Int // Calendar year, e.g. 2025
  month        Int // 1-12 (1 = January)
  category     String // e.g. "NET_SALES" (future-proof for COGS/WASTE/etc)
  amountCents  Int // Budgeted amount in smallest currency unit
  currencyCode String // "UGX", "USD", etc.
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  org    Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@unique([orgId, branchId, year, month, category], name: "franchise_budget_period_key")
  @@index([orgId, year, month])
  @@map("franchise_budgets")
}

// ===== Accounting Core (E40-s1) =====

model Account {
  id        String      @id @default(cuid())
  orgId     String
  code      String // Unique within org (e.g., "1000", "4000")
  name      String // e.g., "Cash", "Sales Revenue"
  type      AccountType
  isActive  Boolean     @default(true)
  parentId  String? // For account hierarchy
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  parent                         Account?                  @relation("AccountHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children                       Account[]                 @relation("AccountHierarchy")
  journalLines                   JournalLine[]
  paymentMethodMappings          PaymentMethodMapping[] // M8.4: Reverse relation
  // M10.8: Payroll posting mapping reverse relations
  laborExpenseMappings           PayrollPostingMapping[]   @relation("LaborExpenseAccount")
  wagesPayableMappings           PayrollPostingMapping[]   @relation("WagesPayableAccount")
  taxesPayableMappings           PayrollPostingMapping[]   @relation("TaxesPayableAccount")
  deductionsPayableMappings      PayrollPostingMapping[]   @relation("DeductionsPayableAccount")
  employerContribExpenseMappings PayrollPostingMapping[]   @relation("EmployerContribExpenseAccount")
  employerContribPayableMappings PayrollPostingMapping[]   @relation("EmployerContribPayableAccount")
  cashAccountMappings            PayrollPostingMapping[]   @relation("CashAccount")
  // M10.9: Remittance line reverse relations
  remittanceLiabilityLines       RemittanceLine[]          @relation("RemittanceLiabilityAccount")
  remittanceCounterLines         RemittanceLine[]          @relation("RemittanceCounterAccount")
  // M10.10: Remittance provider default account relations
  providerLiabilityAccounts      RemittanceProvider[]      @relation("ProviderLiabilityAccount")
  providerCashAccounts           RemittanceProvider[]      @relation("ProviderCashAccount")
  // M11.13: Inventory posting mapping reverse relations
  invAssetMappings               InventoryPostingMapping[] @relation("InvAssetAccount")
  cogsMappings                   InventoryPostingMapping[] @relation("CogsAccount")
  wasteExpenseMappings           InventoryPostingMapping[] @relation("WasteExpenseAccount")
  shrinkExpenseMappings          InventoryPostingMapping[] @relation("ShrinkExpenseAccount")
  grniMappings                   InventoryPostingMapping[] @relation("GrniAccount")
  invGainMappings                InventoryPostingMapping[] @relation("InvGainAccount")

  @@unique([orgId, code])
  @@index([orgId, type])
  @@map("accounts")
}

// M8.4: Payment Method â†’ GL Account Mapping
model PaymentMethodMapping {
  id        String        @id @default(cuid())
  orgId     String
  method    PaymentMethod
  accountId String
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  account Account @relation(fields: [accountId], references: [id], onDelete: Restrict)

  @@unique([orgId, method])
  @@index([orgId])
  @@map("payment_method_mappings")
}

// M11.13: Inventory â†’ GL Posting Mapping
model InventoryPostingMapping {
  id                      String   @id @default(cuid())
  orgId                   String
  branchId                String? // null = org default, specific branchId = branch override
  // Required GL accounts
  inventoryAssetAccountId String
  cogsAccountId           String
  wasteExpenseAccountId   String
  shrinkExpenseAccountId  String
  grniAccountId           String // Goods Received Not Invoiced (liability)
  // Optional GL accounts
  inventoryGainAccountId  String? // For positive stocktake variances
  // Audit
  createdById             String?
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  // Relations
  inventoryAssetAccount Account  @relation("InvAssetAccount", fields: [inventoryAssetAccountId], references: [id], onDelete: Restrict)
  cogsAccount           Account  @relation("CogsAccount", fields: [cogsAccountId], references: [id], onDelete: Restrict)
  wasteExpenseAccount   Account  @relation("WasteExpenseAccount", fields: [wasteExpenseAccountId], references: [id], onDelete: Restrict)
  shrinkExpenseAccount  Account  @relation("ShrinkExpenseAccount", fields: [shrinkExpenseAccountId], references: [id], onDelete: Restrict)
  grniAccount           Account  @relation("GrniAccount", fields: [grniAccountId], references: [id], onDelete: Restrict)
  inventoryGainAccount  Account? @relation("InvGainAccount", fields: [inventoryGainAccountId], references: [id], onDelete: SetNull)
  branch                Branch?  @relation("InventoryPostingMappingBranch", fields: [branchId], references: [id], onDelete: Cascade)
  createdBy             User?    @relation("InventoryPostingMappingCreator", fields: [createdById], references: [id], onDelete: SetNull)

  @@unique([orgId, branchId])
  @@index([orgId])
  @@map("inventory_posting_mappings")
}

model JournalEntry {
  id              String             @id @default(cuid())
  orgId           String
  branchId        String? // Branch where transaction occurred
  date            DateTime           @default(now())
  memo            String?
  source          String? // e.g., "POS_SALE", "REFUND", "CASH_MOVEMENT", "VENDOR_PAYMENT", "MANUAL"
  sourceId        String? // Reference to source entity ID
  status          JournalEntryStatus @default(DRAFT) // M8.2b: Lifecycle status
  postedById      String?
  postedAt        DateTime? // M8.2b: When entry was posted
  reversedById    String? // M8.2b: User who reversed this entry
  reversedAt      DateTime? // M8.2b: When entry was reversed
  reversesEntryId String? // M8.2b: Links reversal to original entry
  createdAt       DateTime           @default(now())

  lines                     JournalLine[]
  reversalOf                JournalEntry?              @relation("JournalReversal", fields: [reversesEntryId], references: [id])
  reversedBy                JournalEntry[]             @relation("JournalReversal")
  // M8.3: Reverse relations for AP/AR documents
  vendorBills               VendorBill[]               @relation("VendorBillJournal")
  vendorPayments            VendorPayment[]            @relation("VendorPaymentJournal")
  customerInvoices          CustomerInvoice[]          @relation("CustomerInvoiceJournal")
  customerReceipts          CustomerReceipt[]          @relation("CustomerReceiptJournal")
  // M8.5: Credit note relations
  customerCreditNotes       CustomerCreditNote[]       @relation("CustomerCreditNoteJournal")
  customerCreditNoteRefunds CustomerCreditNoteRefund[] @relation("CustomerCreditNoteRefundJournal")
  vendorCreditNotes         VendorCreditNote[]         @relation("VendorCreditNoteJournal")
  vendorCreditNoteRefunds   VendorCreditNoteRefund[]   @relation("VendorCreditNoteRefundJournal")
  // M9.2: Reservation deposit relations
  depositJournals           ReservationDeposit[]       @relation("DepositJournal")
  depositRefundJournals     ReservationDeposit[]       @relation("DepositRefundJournal")
  depositApplyJournals      ReservationDeposit[]       @relation("DepositApplyJournal")
  // M10.6: Payroll run journal links
  payrollRunJournalLinks    PayrollRunJournalLink[]
  // M10.9: Remittance journal links
  remittanceJournalLinks    RemittanceJournalLink[]
  // M11.13: Inventory GL journal relations
  goodsReceiptJournals      GoodsReceiptV2[]           @relation("GoodsReceiptGlJournal")
  wasteJournals             InventoryWaste[]           @relation("WasteGlJournal")
  stocktakeJournals         StocktakeSession[]         @relation("StocktakeGlJournal")
  depletionJournals         OrderInventoryDepletion[]  @relation("DepletionGlJournal")

  @@index([orgId, date])
  @@index([orgId, branchId])
  @@index([orgId, status])
  @@index([source, sourceId])
  @@map("journal_entries")
}

model JournalLine {
  id        String   @id @default(cuid())
  entryId   String
  accountId String
  branchId  String?
  debit     Decimal  @default(0) @db.Decimal(12, 2)
  credit    Decimal  @default(0) @db.Decimal(12, 2)
  meta      Json? // Additional context
  createdAt DateTime @default(now())

  entry   JournalEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)
  account Account      @relation(fields: [accountId], references: [id], onDelete: Restrict)

  @@index([entryId])
  @@index([accountId])
  @@map("journal_lines")
}

model Vendor {
  id           String        @id @default(cuid())
  orgId        String
  name         String
  email        String?
  phone        String?
  defaultTerms PaymentTerms? // Default payment terms
  metadata     Json?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  bills                       VendorBill[]
  payments                    VendorPayment[]
  creditNotes                 VendorCreditNote[] // M8.5
  purchaseOrdersV2            PurchaseOrderV2[]          @relation("VendorPurchaseOrders") // M11.2
  // M11.6: Supplier Catalog
  supplierItems               SupplierItem[]             @relation("VendorSupplierItems")
  reorderPolicies             ReorderPolicy[]            @relation("PolicyPreferredVendor")
  suggestionLines             ReorderSuggestionLine[]    @relation("SuggestionVendor")
  // M11.8: Vendor Returns
  vendorReturns               VendorReturn[]             @relation("VendorReturns")
  // M11.14: Optimization Line Vendor Suggestions
  optimizationLineSuggestions ForecastOptimizationLine[] @relation("OptimizationLineVendor")

  @@index([orgId])
  @@map("vendors")
}

model VendorBill {
  id         String     @id @default(cuid())
  orgId      String
  vendorId   String
  number     String? // Vendor's bill number
  billDate   DateTime   @default(now())
  dueDate    DateTime
  subtotal   Decimal    @db.Decimal(12, 2)
  tax        Decimal    @default(0) @db.Decimal(12, 2)
  total      Decimal    @db.Decimal(12, 2)
  paidAmount Decimal    @default(0) @db.Decimal(12, 2) // M8.4: Track partial payments
  status     BillStatus @default(DRAFT)
  memo       String?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  // M8.3: GL Integration
  journalEntryId String? // Links to GL entry when OPEN
  openedAt       DateTime? // When bill was opened
  openedById     String? // User who opened the bill

  vendor            Vendor                       @relation(fields: [vendorId], references: [id], onDelete: Restrict)
  payments          VendorPayment[]
  journalEntry      JournalEntry?                @relation("VendorBillJournal", fields: [journalEntryId], references: [id])
  creditAllocations VendorCreditNoteAllocation[] // M8.5

  @@index([orgId, status])
  @@index([vendorId])
  @@index([dueDate])
  @@index([journalEntryId])
  @@map("vendor_bills")
}

model VendorPayment {
  id        String   @id @default(cuid())
  orgId     String
  vendorId  String
  billId    String? // Optional link to specific bill
  amount    Decimal  @db.Decimal(12, 2)
  paidAt    DateTime @default(now())
  method    String // CASH, CARD, MOMO, BANK
  ref       String? // Payment reference number
  metadata  Json?
  createdAt DateTime @default(now())

  // M8.3: GL Integration
  journalEntryId String? // Links to GL entry

  vendor       Vendor        @relation(fields: [vendorId], references: [id], onDelete: Restrict)
  bill         VendorBill?   @relation(fields: [billId], references: [id], onDelete: SetNull)
  journalEntry JournalEntry? @relation("VendorPaymentJournal", fields: [journalEntryId], references: [id])

  @@index([orgId])
  @@index([vendorId])
  @@index([billId])
  @@index([journalEntryId])
  @@map("vendor_payments")
}

model CustomerAccount {
  id          String   @id @default(cuid())
  orgId       String
  name        String
  email       String?
  phone       String?
  creditLimit Decimal? @db.Decimal(12, 2)
  metadata    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  invoices    CustomerInvoice[]
  receipts    CustomerReceipt[]
  creditNotes CustomerCreditNote[] // M8.5

  @@index([orgId])
  @@map("customer_accounts")
}

model CustomerInvoice {
  id          String        @id @default(cuid())
  orgId       String
  customerId  String
  number      String? // Invoice number
  invoiceDate DateTime      @default(now())
  dueDate     DateTime
  subtotal    Decimal       @db.Decimal(12, 2)
  tax         Decimal       @default(0) @db.Decimal(12, 2)
  total       Decimal       @db.Decimal(12, 2)
  paidAmount  Decimal       @default(0) @db.Decimal(12, 2) // M8.4: Track partial payments
  status      InvoiceStatus @default(DRAFT)
  memo        String? // M8.3: Invoice memo
  metadata    Json?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // M8.3: GL Integration
  journalEntryId String? // Links to GL entry when OPEN
  openedAt       DateTime? // When invoice was opened
  openedById     String? // User who opened the invoice

  customer          CustomerAccount                @relation(fields: [customerId], references: [id], onDelete: Restrict)
  receipts          CustomerReceipt[]
  journalEntry      JournalEntry?                  @relation("CustomerInvoiceJournal", fields: [journalEntryId], references: [id])
  creditAllocations CustomerCreditNoteAllocation[] // M8.5

  @@index([orgId, status])
  @@index([customerId])
  @@index([dueDate])
  @@index([journalEntryId])
  @@map("customer_invoices")
}

// M8.3: Customer Receipt (for AR payments)
model CustomerReceipt {
  id         String   @id @default(cuid())
  orgId      String
  customerId String
  invoiceId  String? // Optional link to specific invoice
  amount     Decimal  @db.Decimal(12, 2)
  receivedAt DateTime @default(now())
  method     String // CASH, CARD, MOMO, BANK
  ref        String? // Payment reference
  metadata   Json?
  createdAt  DateTime @default(now())

  // M8.3: GL Integration
  journalEntryId String? // Links to GL entry

  customer     CustomerAccount  @relation(fields: [customerId], references: [id], onDelete: Restrict)
  invoice      CustomerInvoice? @relation(fields: [invoiceId], references: [id], onDelete: SetNull)
  journalEntry JournalEntry?    @relation("CustomerReceiptJournal", fields: [journalEntryId], references: [id])

  @@index([orgId])
  @@index([customerId])
  @@index([invoiceId])
  @@index([journalEntryId])
  @@map("customer_receipts")
}

// ===== M8.5: Credit Notes + Write-offs + Refund Accounting =====

// M8.5: Customer Credit Note (AR Credit Memo)
model CustomerCreditNote {
  id              String           @id @default(cuid())
  orgId           String
  customerId      String
  number          String? // Credit note number
  creditDate      DateTime         @default(now())
  amount          Decimal          @db.Decimal(12, 2)
  allocatedAmount Decimal          @default(0) @db.Decimal(12, 2) // Sum of allocations
  refundedAmount  Decimal          @default(0) @db.Decimal(12, 2) // Sum of refunds
  status          CreditNoteStatus @default(DRAFT)
  reason          String? // Reason for credit
  memo            String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // GL Integration
  journalEntryId String? // Links to GL entry when OPEN
  openedAt       DateTime? // When credit note was opened
  openedById     String? // User who opened

  customer     CustomerAccount                @relation(fields: [customerId], references: [id], onDelete: Restrict)
  journalEntry JournalEntry?                  @relation("CustomerCreditNoteJournal", fields: [journalEntryId], references: [id])
  allocations  CustomerCreditNoteAllocation[]
  refunds      CustomerCreditNoteRefund[]

  @@index([orgId, status])
  @@index([customerId])
  @@index([journalEntryId])
  @@map("customer_credit_notes")
}

// M8.5: Allocation of customer credit to invoice
model CustomerCreditNoteAllocation {
  id           String   @id @default(cuid())
  creditNoteId String
  invoiceId    String
  amount       Decimal  @db.Decimal(12, 2)
  appliedAt    DateTime @default(now())
  appliedById  String?

  creditNote CustomerCreditNote @relation(fields: [creditNoteId], references: [id], onDelete: Restrict)
  invoice    CustomerInvoice    @relation(fields: [invoiceId], references: [id], onDelete: Restrict)

  @@index([creditNoteId])
  @@index([invoiceId])
  @@map("customer_credit_note_allocations")
}

// M8.5: Refund of customer credit balance
model CustomerCreditNoteRefund {
  id           String   @id @default(cuid())
  creditNoteId String
  amount       Decimal  @db.Decimal(12, 2)
  refundDate   DateTime @default(now())
  method       String // CASH, BANK, CHECK
  ref          String? // Reference number
  memo         String?
  createdAt    DateTime @default(now())

  // GL Integration
  journalEntryId String?

  creditNote   CustomerCreditNote @relation(fields: [creditNoteId], references: [id], onDelete: Restrict)
  journalEntry JournalEntry?      @relation("CustomerCreditNoteRefundJournal", fields: [journalEntryId], references: [id])

  @@index([creditNoteId])
  @@index([journalEntryId])
  @@map("customer_credit_note_refunds")
}

// M8.5: Vendor Credit Note (AP Debit Memo - credits from vendor)
model VendorCreditNote {
  id              String           @id @default(cuid())
  orgId           String
  vendorId        String
  number          String? // Credit note number
  creditDate      DateTime         @default(now())
  amount          Decimal          @db.Decimal(12, 2)
  allocatedAmount Decimal          @default(0) @db.Decimal(12, 2)
  refundedAmount  Decimal          @default(0) @db.Decimal(12, 2)
  status          CreditNoteStatus @default(DRAFT)
  reason          String?
  memo            String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // GL Integration
  journalEntryId String?
  openedAt       DateTime?
  openedById     String?

  vendor       Vendor                       @relation(fields: [vendorId], references: [id], onDelete: Restrict)
  journalEntry JournalEntry?                @relation("VendorCreditNoteJournal", fields: [journalEntryId], references: [id])
  allocations  VendorCreditNoteAllocation[]
  refunds      VendorCreditNoteRefund[]

  @@index([orgId, status])
  @@index([vendorId])
  @@index([journalEntryId])
  @@map("vendor_credit_notes")
}

// M8.5: Allocation of vendor credit to bill
model VendorCreditNoteAllocation {
  id           String   @id @default(cuid())
  creditNoteId String
  billId       String
  amount       Decimal  @db.Decimal(12, 2)
  appliedAt    DateTime @default(now())
  appliedById  String?

  creditNote VendorCreditNote @relation(fields: [creditNoteId], references: [id], onDelete: Restrict)
  bill       VendorBill       @relation(fields: [billId], references: [id], onDelete: Restrict)

  @@index([creditNoteId])
  @@index([billId])
  @@map("vendor_credit_note_allocations")
}

// M8.5: Refund of vendor credit balance (receiving cash back)
model VendorCreditNoteRefund {
  id           String   @id @default(cuid())
  creditNoteId String
  amount       Decimal  @db.Decimal(12, 2)
  refundDate   DateTime @default(now())
  method       String // CASH, BANK, CHECK
  ref          String?
  memo         String?
  createdAt    DateTime @default(now())

  // GL Integration
  journalEntryId String?

  creditNote   VendorCreditNote @relation(fields: [creditNoteId], references: [id], onDelete: Restrict)
  journalEntry JournalEntry?    @relation("VendorCreditNoteRefundJournal", fields: [journalEntryId], references: [id])

  @@index([creditNoteId])
  @@index([journalEntryId])
  @@map("vendor_credit_note_refunds")
}

model ReminderSchedule {
  id        String          @id @default(cuid())
  orgId     String
  type      ReminderType
  targetId  String? // Vendor ID for VENDOR_BILL, null for UTILITY
  channel   ReminderChannel
  whenDays  Int // Days before due date
  isActive  Boolean         @default(true)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@index([orgId, isActive])
  @@map("reminder_schedules")
}

// ===== E39-s1: Multi-currency & Tax Matrix =====

model Currency {
  code     String @id // ISO 4217: "UGX", "USD", "EUR"
  name     String // "Ugandan Shilling", "US Dollar"
  symbol   String // "USh", "$", "â‚¬"
  decimals Int    @default(0) // 0 for UGX, 2 for USD

  baseRates  ExchangeRate[] @relation("BaseCurrency")
  quoteRates ExchangeRate[] @relation("QuoteCurrency")

  @@map("currencies")
}

model ExchangeRate {
  id        String   @id @default(cuid())
  baseCode  String // "UGX"
  quoteCode String // "USD"
  rate      Decimal  @db.Decimal(18, 6) // 3700.000000 UGX per 1 USD
  asOf      DateTime @default(now())
  source    String? // "MANUAL", "BOU", "XE"
  createdAt DateTime @default(now())

  base  Currency @relation("BaseCurrency", fields: [baseCode], references: [code], onDelete: Cascade)
  quote Currency @relation("QuoteCurrency", fields: [quoteCode], references: [code], onDelete: Cascade)

  @@unique([baseCode, quoteCode, asOf])
  @@index([baseCode, quoteCode])
  @@map("exchange_rates")
}

// ===== E42-s1: Public Bookings Portal =====

model Event {
  id                String   @id @default(cuid())
  orgId             String
  branchId          String
  slug              String   @unique
  title             String
  description       String?
  startsAt          DateTime
  endsAt            DateTime
  isPublished       Boolean  @default(false)
  floorPlanSnapshot Json? // Snapshot of floor plan for historical reference
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  tables   EventTable[]
  bookings EventBooking[]

  @@index([orgId, branchId])
  @@index([slug])
  @@index([isPublished, startsAt])
  @@map("events")
}

model EventTable {
  id           String  @id @default(cuid())
  eventId      String
  tableId      String? // Optional link to actual floor plan table
  label        String // "VIP Table 1", "Rooftop A"
  capacity     Int
  price        Decimal @db.Decimal(12, 2) // Full table price
  minSpend     Decimal @db.Decimal(12, 2) // Minimum spend requirement
  deposit      Decimal @db.Decimal(12, 2) // Upfront deposit required
  allowPartial Boolean @default(true) // Allow partial bookings
  isActive     Boolean @default(true)

  event    Event          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  bookings EventBooking[]

  @@index([eventId, isActive])
  @@map("event_tables")
}

model EventBooking {
  id              String             @id @default(cuid())
  eventId         String
  eventTableId    String
  name            String
  phone           String
  email           String?
  status          EventBookingStatus @default(HELD)
  depositIntentId String? // PaymentIntent ID for deposit
  depositCaptured Boolean            @default(false)
  creditTotal     Decimal            @default(0) @db.Decimal(12, 2) // Total credit eligible after deposit
  ticketCode      String?            @unique // E42-s2: ULID for QR check-in
  checkedInAt     DateTime? // E42-s2: When guest checked in
  checkedInById   String? // E42-s2: User who performed check-in
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt
  metadata        Json? // Additional booking details

  event      Event           @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventTable EventTable      @relation(fields: [eventTableId], references: [id], onDelete: Cascade)
  credits    PrepaidCredit[]
  documents  Document[]
  feedback   Feedback? // M20: Customer feedback for this event booking

  @@index([eventId, status])
  @@index([eventTableId])
  @@index([phone])
  @@map("event_bookings")
}

model PrepaidCredit {
  id             String   @id @default(cuid())
  orgId          String
  branchId       String
  eventBookingId String? // Link to event booking if applicable
  tableId        String? // Link to actual table when applied
  amount         Decimal  @db.Decimal(12, 2) // Total credit amount
  consumed       Decimal  @default(0) @db.Decimal(12, 2) // Amount already used
  expiresAt      DateTime
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  eventBooking EventBooking? @relation(fields: [eventBookingId], references: [id], onDelete: SetNull)

  @@index([orgId, branchId, expiresAt])
  @@index([eventBookingId])
  @@index([tableId])
  @@map("prepaid_credits")
}

// ===== M10.17: Enhanced Workforce Leave Management =====

// M10.17: Leave Type Definition (org-level)
model LeaveTypeDefinition {
  id                 String        @id @default(cuid())
  orgId              String
  name               String // e.g., "Annual Leave", "Sick Leave"
  code               LeaveTypeCode
  isPaid             Boolean       @default(true)
  requiresApproval   Boolean       @default(true)
  minNoticeHours     Int           @default(0) // Minimum notice required
  maxConsecutiveDays Int           @default(30) // Maximum consecutive days
  isActive           Boolean       @default(true)
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  policies      LeavePolicy[]
  leaveRequests LeaveRequestV2[]
  balanceLedger LeaveBalanceLedger[]

  @@unique([orgId, code])
  @@index([orgId, isActive])
  @@map("leave_type_definitions")
}

// M10.17: Leave Policy with accrual rules
// M10.18: Added approvalMode for multi-step approvals
model LeavePolicy {
  id                    String        @id @default(cuid())
  orgId                 String
  branchId              String? // Optional branch override
  leaveTypeId           String
  name                  String
  accrualMethod         AccrualMethod @default(NONE)
  accrualRate           Decimal       @default(0) @db.Decimal(10, 4) // Hours per unit
  carryoverMaxHours     Decimal       @default(0) @db.Decimal(10, 2)
  maxBalanceHours       Decimal       @default(480) @db.Decimal(10, 2) // Cap at ~60 days
  roundingPrecision     Int           @default(2) // Decimal places for rounding
  maxUninformedAbsences Int           @default(0)
  approvalMode          ApprovalMode  @default(SINGLE) // M10.18: SINGLE or TWO_STEP
  isActive              Boolean       @default(true)
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  leaveType LeaveTypeDefinition @relation(fields: [leaveTypeId], references: [id], onDelete: Cascade)

  @@unique([orgId, leaveTypeId, branchId])
  @@index([orgId, isActive])
  @@map("leave_policies")
}

// M10.17: Enhanced Leave Request with workflow states
// M10.18: Added two-step approval fields and attachments
model LeaveRequestV2 {
  id                String             @id @default(cuid())
  orgId             String
  branchId          String
  userId            String
  leaveTypeId       String
  startDate         DateTime
  endDate           DateTime
  totalHours        Decimal            @db.Decimal(10, 2)
  status            LeaveRequestStatus @default(DRAFT)
  reason            String?
  // M10.18: Two-step approval fields
  approvedStep1ById String?
  approvedStep1At   DateTime?
  approvedById      String? // Final approver (or step2 approver)
  approvedAt        DateTime?
  rejectionReason   String?
  rejectedStep      Int? // 1 or 2, which step rejected
  overrideConflict  Boolean            @default(false) // M10.17: Override shift conflict
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  user            User                     @relation("LeaveRequestsV2", fields: [userId], references: [id], onDelete: Cascade)
  approvedBy      User?                    @relation("ApprovedLeaveV2", fields: [approvedById], references: [id], onDelete: SetNull)
  approvedStep1By User?                    @relation("ApprovedLeaveStep1", fields: [approvedStep1ById], references: [id], onDelete: SetNull)
  leaveType       LeaveTypeDefinition      @relation(fields: [leaveTypeId], references: [id], onDelete: Restrict)
  ledgerEntries   LeaveBalanceLedger[]
  attachments     LeaveRequestAttachment[] // M10.18

  @@index([orgId, branchId, status])
  @@index([userId, startDate, endDate])
  @@index([leaveTypeId])
  @@map("leave_requests_v2")
}

// M10.17: Leave Balance Ledger for accrual tracking
model LeaveBalanceLedger {
  id            String          @id @default(cuid())
  orgId         String
  userId        String
  leaveTypeId   String
  entryType     LedgerEntryType
  deltaHours    Decimal         @db.Decimal(10, 4) // Can be negative for corrections
  balanceAfter  Decimal         @db.Decimal(10, 4) // Running balance
  reason        String // e.g., "Monthly accrual", "Leave approved", "Manual adjustment"
  referenceId   String? // Link to LeaveRequestV2 or accrual run
  referenceType String? // "LEAVE_REQUEST" | "ACCRUAL" | "MANUAL" | "CARRYOVER"
  createdAt     DateTime        @default(now())

  user         User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  leaveType    LeaveTypeDefinition @relation(fields: [leaveTypeId], references: [id], onDelete: Restrict)
  leaveRequest LeaveRequestV2?     @relation(fields: [referenceId], references: [id], onDelete: SetNull)

  @@index([orgId, userId, leaveTypeId])
  @@index([createdAt])
  @@index([referenceId])
  @@map("leave_balance_ledger")
}

// M10.18: Leave Request Attachment Metadata
model LeaveRequestAttachment {
  id             String   @id @default(cuid())
  orgId          String
  leaveRequestId String
  label          String // e.g., "Doctor's note", "Medical certificate"
  url            String? // External URL (validated, HTTPS preferred)
  mimeType       String? // e.g., "application/pdf", "image/jpeg"
  sizeBytes      Int? // File size in bytes
  addedById      String
  createdAt      DateTime @default(now())

  leaveRequest LeaveRequestV2 @relation(fields: [leaveRequestId], references: [id], onDelete: Cascade)
  addedBy      User           @relation("LeaveAttachmentAddedBy", fields: [addedById], references: [id], onDelete: Cascade)

  @@index([leaveRequestId])
  @@index([orgId])
  @@map("leave_request_attachments")
}

// M10.18: Approval Delegation for managers
model ApprovalDelegate {
  id              String   @id @default(cuid())
  orgId           String
  principalUserId String // The manager who is delegating
  delegateUserId  String // The user who can act on their behalf
  branchId        String? // null = org-wide, specific = branch-only
  startAt         DateTime
  endAt           DateTime
  enabled         Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  principal User @relation("DelegatingUser", fields: [principalUserId], references: [id], onDelete: Cascade)
  delegate  User @relation("DelegateUser", fields: [delegateUserId], references: [id], onDelete: Cascade)

  @@index([orgId, principalUserId, enabled])
  @@index([orgId, delegateUserId])
  @@index([startAt, endAt])
  @@map("approval_delegates")
}

// Legacy model kept for backward compatibility
model LegacyLeaveRequest {
  id           String             @id @default(cuid())
  orgId        String
  userId       String
  type         LeaveType
  startDate    DateTime
  endDate      DateTime
  status       LeaveRequestStatus @default(DRAFT)
  approvedById String?
  approvedAt   DateTime?
  reason       String?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  user       User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  approvedBy User? @relation("ApprovedLeave", fields: [approvedById], references: [id], onDelete: SetNull)

  @@index([orgId, userId, status])
  @@index([startDate, endDate])
  @@map("leave_requests")
}

model DutyShift {
  id           String   @id @default(cuid())
  orgId        String
  branchId     String
  userId       String
  startsAt     DateTime
  endsAt       DateTime
  roleSlug     String
  assignedById String?
  notes        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  assignedBy        User?              @relation("AssignedShifts", fields: [assignedById], references: [id], onDelete: SetNull)
  swaps             ShiftSwap[]
  attendanceRecords AttendanceRecord[] // M9: Attendance records for this shift

  @@index([orgId, branchId, startsAt])
  @@index([userId, startsAt])
  @@map("duty_shifts")
}

model ShiftSwap {
  id           String          @id @default(cuid())
  orgId        String
  fromUserId   String
  toUserId     String
  dutyShiftId  String
  status       ShiftSwapStatus @default(PENDING)
  approvedById String?
  decidedAt    DateTime?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  fromUser   User      @relation("SwapFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser     User      @relation("SwapTo", fields: [toUserId], references: [id], onDelete: Cascade)
  dutyShift  DutyShift @relation(fields: [dutyShiftId], references: [id], onDelete: Cascade)
  approvedBy User?     @relation("ApprovedSwaps", fields: [approvedById], references: [id], onDelete: SetNull)

  @@index([orgId, status])
  @@index([dutyShiftId])
  @@map("shift_swaps")
}

model TimeEntry {
  id                     String          @id @default(cuid())
  orgId                  String
  branchId               String
  userId                 String
  shiftId                String? // M10.1: Link to scheduled shift
  clockInAt              DateTime
  clockOutAt             DateTime?
  method                 TimeClockMethod
  approved               Boolean         @default(false)
  approvedById           String?
  overtimeMinutes        Int             @default(0)
  // M10.19: Geo-fencing Metadata (optional)
  clockInLat             Float? // Latitude of clock-in
  clockInLng             Float? // Longitude of clock-in
  clockInAccuracyMeters  Float? // GPS accuracy in meters
  clockInSource          String? // GPS, WIFI, MANUAL
  clockOutLat            Float? // Latitude of clock-out
  clockOutLng            Float? // Longitude of clock-out
  clockOutAccuracyMeters Float? // GPS accuracy in meters
  clockOutSource         String? // GPS, WIFI, MANUAL
  // M10.20: Geo-fence Override Fields
  clockInOverride        Boolean? // True if clock-in was overridden
  clockInOverrideReason  String? // Manager's reason for override
  clockInOverrideById    String? // Manager who approved override
  clockOutOverride       Boolean? // True if clock-out was overridden
  clockOutOverrideReason String? // Manager's reason for override
  clockOutOverrideById   String? // Manager who approved override
  createdAt              DateTime        @default(now())
  updatedAt              DateTime        @updatedAt

  user                User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  approvedBy          User?                 @relation("ApprovedTimeEntries", fields: [approvedById], references: [id], onDelete: SetNull)
  clockInOverrideBy   User?                 @relation("ClockInOverrideBy", fields: [clockInOverrideById], references: [id], onDelete: SetNull)
  clockOutOverrideBy  User?                 @relation("ClockOutOverrideBy", fields: [clockOutOverrideById], references: [id], onDelete: SetNull)
  scheduledShift      ScheduledShift?       @relation(fields: [shiftId], references: [id], onDelete: SetNull)
  breakEntries        BreakEntry[]
  timesheetApproval   TimesheetApproval? // M10.3: Timesheet approval record
  adjustments         TimeEntryAdjustment[] // M10.5: Adjustment requests
  complianceIncidents OpsIncident[] // M10.19: Break compliance incidents

  @@index([orgId, branchId, clockInAt])
  @@index([userId, clockInAt])
  @@index([shiftId])
  @@map("time_entries")
}

// ===== M10.20: Branch Geo-Fence Configuration =====

model BranchGeoFence {
  id                   String   @id @default(cuid())
  orgId                String
  branchId             String   @unique // One geo-fence per branch
  enabled              Boolean  @default(false)
  centerLat            Float // Center latitude
  centerLng            Float // Center longitude
  radiusMeters         Int      @default(100) // Enforcement radius
  enforceClockIn       Boolean  @default(true)
  enforceClockOut      Boolean  @default(true)
  allowManagerOverride Boolean  @default(true)
  maxAccuracyMeters    Int      @default(200) // H7: Reject readings worse than this
  createdById          String?
  updatedById          String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  org       Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch    Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)
  createdBy User?  @relation("GeoFenceCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  updatedBy User?  @relation("GeoFenceUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)

  @@index([orgId])
  @@index([branchId])
  @@map("branch_geo_fences")
}

// ===== M10.20: Geo-fence Event Log =====

model GeoFenceEvent {
  id             String   @id @default(cuid())
  orgId          String
  branchId       String
  userId         String
  eventType      String // BLOCKED, OVERRIDE_APPROVED, ACCURACY_FAILURE
  reasonCode     String? // OUTSIDE_GEOFENCE, ACCURACY_TOO_LOW, MISSING_LOCATION
  clockAction    String // CLOCK_IN, CLOCK_OUT
  lat            Float?
  lng            Float?
  accuracyMeters Float?
  distanceMeters Float?
  radiusMeters   Int?
  overrideById   String?
  overrideReason String?
  createdAt      DateTime @default(now())

  org        Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch     Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)
  user       User   @relation("GeoFenceEventUser", fields: [userId], references: [id], onDelete: Cascade)
  overrideBy User?  @relation("GeoFenceEventOverrideBy", fields: [overrideById], references: [id], onDelete: SetNull)

  @@index([orgId, branchId, createdAt])
  @@index([userId])
  @@index([eventType])
  @@map("geo_fence_events")
}

// ===== M10.1: Workforce Core - Shift Scheduling =====

model ScheduledShift {
  id              String      @id @default(cuid())
  orgId           String
  branchId        String
  userId          String? // M10.11: Nullable for open shifts
  role            String // jobRole slug
  startAt         DateTime
  endAt           DateTime
  plannedMinutes  Int
  actualMinutes   Int?
  breakMinutes    Int?
  overtimeMinutes Int?
  notes           String?
  status          ShiftStatus @default(DRAFT)
  isOpen          Boolean     @default(false) // M10.11: Open shift flag
  publishedAt     DateTime?
  publishedById   String?
  approvedAt      DateTime?
  approvedById    String?
  cancelledAt     DateTime?
  cancelledById   String?
  cancelReason    String?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  org                     Org                @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch                  Branch             @relation("ScheduledShifts", fields: [branchId], references: [id], onDelete: Cascade)
  user                    User?              @relation("AssignedScheduledShifts", fields: [userId], references: [id], onDelete: Cascade)
  publishedBy             User?              @relation("PublishedScheduledShifts", fields: [publishedById], references: [id], onDelete: SetNull)
  approvedBy              User?              @relation("ApprovedScheduledShifts", fields: [approvedById], references: [id], onDelete: SetNull)
  cancelledBy             User?              @relation("CancelledScheduledShifts", fields: [cancelledById], references: [id], onDelete: SetNull)
  timeEntries             TimeEntry[]
  // M10.11: Swap relations
  swapRequestsAsRequester ShiftSwapRequest[] @relation("RequesterShift")
  swapRequestsAsTarget    ShiftSwapRequest[] @relation("TargetShift")
  openShiftClaims         OpenShiftClaim[]

  @@index([orgId, branchId, startAt])
  @@index([userId, startAt])
  @@index([status])
  @@index([isOpen])
  @@map("scheduled_shifts")
}

model BreakEntry {
  id          String    @id @default(cuid())
  timeEntryId String
  startedAt   DateTime
  endedAt     DateTime?
  minutes     Int?
  createdAt   DateTime  @default(now())

  timeEntry TimeEntry @relation(fields: [timeEntryId], references: [id], onDelete: Cascade)

  @@index([timeEntryId])
  @@map("break_entries")
}

model WorkforceAuditLog {
  id            String   @id @default(cuid())
  orgId         String
  action        String // SHIFT_CREATED, CLOCK_IN, etc.
  entityType    String // Shift, TimeEntry, etc.
  entityId      String
  performedById String
  payload       Json?
  createdAt     DateTime @default(now())

  org         Org  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  performedBy User @relation(fields: [performedById], references: [id], onDelete: Cascade)

  @@index([orgId, action])
  @@index([entityType, entityId])
  @@index([performedById])
  @@map("workforce_audit_logs")
}

// ===== M9: HR & Payroll Enterprise Hardening =====

enum EmploymentType {
  PERMANENT
  TEMPORARY
  CASUAL
}

enum EmploymentStatus {
  ACTIVE
  INACTIVE
  TERMINATED
}

enum SalaryType {
  MONTHLY
  DAILY
  HOURLY
  PER_SHIFT
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  LEFT_EARLY
  COVERED
}

enum AttendanceSource {
  MANUAL
  CLOCK
  KDS
  POS
  IMPORT
}

enum AwardPeriodType {
  WEEK
  MONTH
  QUARTER
  YEAR
}

enum AwardCategory {
  TOP_PERFORMER
  HIGHEST_SALES
  BEST_SERVICE
  MOST_RELIABLE
  MOST_IMPROVED
}

// M22: Promotion Suggestions
enum SuggestionCategory {
  PROMOTION
  ROLE_CHANGE
  TRAINING
  PERFORMANCE_REVIEW
}

enum SuggestionStatus {
  PENDING
  ACCEPTED
  REJECTED
  IGNORED
}

model Employee {
  id             String           @id @default(cuid())
  orgId          String
  branchId       String?
  userId         String?          @unique // Nullable for temp staff without login
  employeeCode   String           @unique
  firstName      String
  lastName       String
  position       String?
  employmentType EmploymentType   @default(PERMANENT)
  status         EmploymentStatus @default(ACTIVE)
  hiredAt        DateTime
  terminatedAt   DateTime?
  metadata       Json?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  user                 User?                 @relation(fields: [userId], references: [id], onDelete: SetNull)
  contracts            EmploymentContract[]
  attendanceRecords    AttendanceRecord[]
  coveredAttendance    AttendanceRecord[]    @relation("CoveredAttendance") // M9: Attendance records where this employee covered for someone
  sessions             Session[] // M10: Auth sessions for this employee
  msrCard              MsrCard? // M10: MSR card assignment for this employee
  documents            Document[]
  awards               StaffAward[] // M19: Awards received by this employee
  promotionSuggestions PromotionSuggestion[] @relation("PromotionSuggestions") // M22: Promotion suggestions for this employee

  @@index([orgId, status])
  @@index([branchId, status])
  @@index([employeeCode])
  @@map("employees")
}

model EmploymentContract {
  id                  String     @id @default(cuid())
  employeeId          String
  orgId               String
  branchId            String?
  salaryType          SalaryType
  baseSalary          Decimal    @db.Decimal(12, 2)
  currency            String     @default("UGX")
  deductionRule       Json? // e.g., { dailyRate: baseSalary / 22, hourlyRate: baseSalary / 176 }
  overtimeRate        Decimal    @default(1.5) @db.Decimal(5, 2)
  workingDaysPerMonth Int        @default(22)
  workingHoursPerDay  Int        @default(8)
  startDate           DateTime
  endDate             DateTime?
  isPrimary           Boolean    @default(true)
  metadata            Json?
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([employeeId, isPrimary])
  @@index([orgId, startDate])
  @@map("employment_contracts")
}

model AttendanceRecord {
  id                   String           @id @default(cuid())
  employeeId           String
  orgId                String
  branchId             String
  dutyShiftId          String?
  date                 DateTime         @db.Date
  clockInAt            DateTime?
  clockOutAt           DateTime?
  status               AttendanceStatus @default(PRESENT)
  coveredForEmployeeId String?
  source               AttendanceSource @default(MANUAL)
  notes                String?
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt

  employee           Employee   @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  dutyShift          DutyShift? @relation(fields: [dutyShiftId], references: [id], onDelete: SetNull)
  coveredForEmployee Employee?  @relation("CoveredAttendance", fields: [coveredForEmployeeId], references: [id], onDelete: SetNull)

  @@unique([employeeId, date])
  @@index([orgId, date])
  @@index([branchId, date])
  @@index([employeeId, status])
  @@map("attendance_records")
}

// M19: Staff Awards & Recognition
model StaffAward {
  id            String          @id @default(cuid())
  orgId         String
  branchId      String?
  employeeId    String
  periodType    AwardPeriodType
  periodStart   DateTime
  periodEnd     DateTime
  category      AwardCategory   @default(TOP_PERFORMER)
  rank          Int             @default(1) // 1st, 2nd, 3rd place
  score         Decimal         @db.Decimal(10, 4)
  reason        String?
  scoreSnapshot Json? // Full metrics at award time
  createdAt     DateTime        @default(now())
  createdById   String

  employee  Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  org       Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch    Branch?  @relation(fields: [branchId], references: [id], onDelete: Cascade)
  createdBy User     @relation("CreatedAwards", fields: [createdById], references: [id], onDelete: Restrict)

  @@unique([orgId, employeeId, periodType, periodStart, rank])
  @@index([orgId, periodType, periodStart])
  @@index([employeeId])
  @@index([branchId, periodType, periodStart])
  @@map("staff_awards")
}

// M22: Promotion Suggestions
model PromotionSuggestion {
  id                String             @id @default(cuid())
  orgId             String
  branchId          String? // NULL for org-level suggestions
  employeeId        String
  periodType        AwardPeriodType // Reuse M19 enum
  periodStart       DateTime
  periodEnd         DateTime
  category          SuggestionCategory
  scoreAtSuggestion Decimal            @db.Decimal(10, 4) // Composite score 0-1
  insightsSnapshot  Json? // Full M19 metrics at suggestion time
  reason            String // Why suggested (auto-generated or manual)
  status            SuggestionStatus   @default(PENDING)
  statusUpdatedAt   DateTime?
  statusUpdatedById String?
  decisionNotes     String? // Why accepted/rejected (freetext)
  createdAt         DateTime           @default(now())
  createdById       String? // User who generated (NULL if auto-generated)

  org             Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch          Branch?  @relation(fields: [branchId], references: [id], onDelete: SetNull)
  employee        Employee @relation("PromotionSuggestions", fields: [employeeId], references: [id], onDelete: Cascade)
  statusUpdatedBy User?    @relation("SuggestionDecisions", fields: [statusUpdatedById], references: [id])
  createdBy       User?    @relation("SuggestionCreators", fields: [createdById], references: [id])

  @@unique([orgId, employeeId, periodType, periodStart, category])
  @@index([orgId, branchId, periodStart])
  @@index([employeeId, periodStart])
  @@index([status])
  @@map("promotion_suggestions")
}

// ===== M20: Customer Feedback & NPS =====

model Feedback {
  id       String  @id @default(cuid())
  orgId    String
  branchId String?

  // Entity linkage (at most one should be set)
  orderId        String? @unique
  reservationId  String? @unique
  eventBookingId String? @unique

  // Feedback content
  channel       FeedbackChannel @default(OTHER)
  score         Int // 0-10 (NPS scale)
  npsCategory   NpsCategory // Derived from score
  comment       String?         @db.Text
  tags          String[]        @default([])
  sentimentHint String? // "positive", "negative", "neutral" (for future ML)

  // Attribution
  createdById String? // Nullable for anonymous feedback
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  org          Org           @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch       Branch?       @relation(fields: [branchId], references: [id], onDelete: Cascade)
  order        Order?        @relation(fields: [orderId], references: [id], onDelete: Cascade)
  reservation  Reservation?  @relation(fields: [reservationId], references: [id], onDelete: Cascade)
  eventBooking EventBooking? @relation(fields: [eventBookingId], references: [id], onDelete: Cascade)
  createdBy    User?         @relation("UserFeedback", fields: [createdById], references: [id], onDelete: SetNull)

  // Indexes
  @@index([orgId, createdAt])
  @@index([branchId, createdAt])
  @@index([orderId])
  @@index([reservationId])
  @@index([eventBookingId])
  @@index([npsCategory, createdAt])
  @@index([score])
  @@map("feedback")
}

// ===== M21: Idempotency Infrastructure =====

model IdempotencyKey {
  id           String   @id @default(cuid())
  key          String   @unique // Idempotency-Key header value (ULID recommended)
  endpoint     String // e.g., "POST /pos/orders"
  requestHash  String // SHA256 of normalized request body
  responseBody Json // Cached response (for replay)
  statusCode   Int // HTTP status code (200, 201, 422, etc.)
  expiresAt    DateTime // TTL: 24 hours from creation
  createdAt    DateTime @default(now())

  @@index([expiresAt]) // For cleanup queries (daily cron)
  @@map("idempotency_keys")
}

// ===== E43-s2: Payroll =====

enum PayRunStatus {
  DRAFT
  APPROVED
  POSTED
}

enum PayComponentType {
  EARNING
  DEDUCTION
}

enum PayComponentCalc {
  FIXED
  RATE
  PERCENT
}

enum FlagAction {
  CREATE
  UPDATE
  TOGGLE
  KILL
}

enum FiscalPeriodStatus {
  OPEN
  CLOSED
  LOCKED
}

enum ReconcileSource {
  PAYMENT
  REFUND
  CASH_SAFE_DROP
  CASH_PICKUP
}

model PayRun {
  id          String       @id @default(cuid())
  orgId       String
  periodStart DateTime
  periodEnd   DateTime
  status      PayRunStatus @default(DRAFT)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  slips     PaySlip[]
  documents Document[]

  @@index([orgId, periodStart, periodEnd])
  @@map("pay_runs")
}

model PaySlip {
  id                String    @id @default(cuid())
  payRunId          String
  userId            String
  employeeId        String? // M9: Link to Employee (nullable for backward compat)
  regularMinutes    Int       @default(0)
  overtimeMinutes   Int       @default(0)
  daysPresent       Int       @default(0) // M9: Days attended
  daysAbsent        Int       @default(0) // M9: Days absent (unpaid)
  absenceDeductions Decimal   @default(0) @db.Decimal(12, 2) // M9: Deductions for absences
  gross             Decimal   @default(0) @db.Decimal(12, 2)
  tax               Decimal   @default(0) @db.Decimal(12, 2)
  deductions        Decimal   @default(0) @db.Decimal(12, 2)
  net               Decimal   @default(0) @db.Decimal(12, 2)
  metadata          Json? // M9: Calculation details (salaryType, baseSalary, rates, etc.)
  approvedById      String?
  approvedAt        DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  payRun     PayRun     @relation(fields: [payRunId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  approvedBy User?      @relation("ApprovedPaySlips", fields: [approvedById], references: [id], onDelete: SetNull)
  documents  Document[]

  @@index([payRunId, userId])
  @@index([employeeId])
  @@map("pay_slips")
}

model PayComponent {
  id        String           @id @default(cuid())
  orgId     String
  name      String
  type      PayComponentType
  calc      PayComponentCalc
  value     Decimal          @db.Decimal(12, 2)
  taxable   Boolean          @default(true)
  active    Boolean          @default(true)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  @@index([orgId, active])
  @@map("pay_components")
}

// ===== E49-s1: Change Control & Staged Rollouts =====

model FeatureFlag {
  id          String   @id @default(cuid())
  orgId       String?
  key         String   @unique
  description String?
  active      Boolean  @default(false)
  rolloutPct  Int      @default(0)
  scopes      Json?
  createdById String?
  updatedById String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  createdBy User? @relation("CreatedFlags", fields: [createdById], references: [id], onDelete: SetNull)
  updatedBy User? @relation("UpdatedFlags", fields: [updatedById], references: [id], onDelete: SetNull)

  @@index([orgId, active])
  @@index([key])
  @@map("feature_flags")
}

model MaintenanceWindow {
  id          String   @id @default(cuid())
  orgId       String?
  startsAt    DateTime
  endsAt      DateTime
  message     String?
  blockWrites Boolean  @default(true)
  createdById String?
  createdAt   DateTime @default(now())

  createdBy User? @relation("CreatedMaintenanceWindows", fields: [createdById], references: [id], onDelete: SetNull)

  @@index([orgId, startsAt, endsAt])
  @@map("maintenance_windows")
}

model FlagAudit {
  id        String     @id @default(cuid())
  flagKey   String
  userId    String?
  action    FlagAction
  before    Json?
  after     Json?
  createdAt DateTime   @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([flagKey, createdAt])
  @@index([userId])
  @@map("flag_audits")
}

// ===== E40-s2: Period Locks + Bank Reconciliation =====

model FiscalPeriod {
  id         String             @id @default(cuid())
  orgId      String
  name       String
  startsAt   DateTime
  endsAt     DateTime
  status     FiscalPeriodStatus @default(OPEN)
  closedById String?
  closedAt   DateTime?
  lockedById String?
  lockedAt   DateTime?
  createdAt  DateTime           @default(now())

  @@index([orgId, status])
  @@index([orgId, startsAt, endsAt])
  @@map("fiscal_periods")
}

model BankAccount {
  id           String   @id @default(cuid())
  orgId        String
  name         String
  currencyCode String   @default("UGX")
  lastFour     String?
  createdAt    DateTime @default(now())

  statements   BankStatement[]
  transactions BankTxn[]

  @@index([orgId])
  @@map("bank_accounts")
}

model BankStatement {
  id            String   @id @default(cuid())
  bankAccountId String
  periodStart   DateTime
  periodEnd     DateTime
  opening       Decimal  @db.Decimal(12, 2)
  closing       Decimal  @db.Decimal(12, 2)
  source        String?
  createdAt     DateTime @default(now())

  bankAccount  BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  transactions BankTxn[]
  documents    Document[]

  @@index([bankAccountId, periodStart])
  @@map("bank_statements")
}

model BankTxn {
  id            String   @id @default(cuid())
  bankAccountId String
  postedAt      DateTime
  amount        Decimal  @db.Decimal(12, 2)
  description   String?
  ref           String?
  statementId   String?
  reconciled    Boolean  @default(false)
  createdAt     DateTime @default(now())

  bankAccount BankAccount      @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)
  statement   BankStatement?   @relation(fields: [statementId], references: [id], onDelete: SetNull)
  matches     ReconcileMatch[]

  @@index([bankAccountId, postedAt])
  @@index([reconciled])
  @@map("bank_txns")
}

model ReconcileMatch {
  id          String          @id @default(cuid())
  bankTxnId   String
  source      ReconcileSource
  sourceId    String
  matchedAt   DateTime        @default(now())
  matchedById String?

  bankTxn BankTxn @relation(fields: [bankTxnId], references: [id], onDelete: Cascade)

  @@unique([bankTxnId])
  @@index([source, sourceId])
  @@map("reconcile_matches")
}

// ===== M7: Service Providers, Utilities & Budgets =====

enum ServiceProviderCategory {
  RENT
  INTERNET
  ELECTRICITY
  WATER
  DJ
  PHOTOGRAPHER
  MARKETING
  SECURITY
  CLEANING
  MAINTENANCE
  OTHER
}

enum ContractFrequency {
  MONTHLY
  WEEKLY
  DAILY
  ONE_OFF
}

enum ContractStatus {
  ACTIVE
  PAUSED
  CANCELLED
}

enum ReminderStatus {
  PENDING
  SENT
  ACKED
  IGNORED
  PAID
}

enum ReminderSeverity {
  OVERDUE
  DUE_TODAY
  DUE_SOON
}

enum BudgetCategory {
  STOCK
  PAYROLL
  SERVICE_PROVIDERS
  UTILITIES
  RENT
  MARKETING
  MISC
}

enum CostInsightSeverity {
  LOW
  MEDIUM
  HIGH
}

model ServiceProvider {
  id           String                  @id @default(cuid())
  orgId        String
  branchId     String?
  name         String
  category     ServiceProviderCategory
  contactName  String?
  contactEmail String?
  contactPhone String?
  isActive     Boolean                 @default(true)
  notes        String?
  createdAt    DateTime                @default(now())
  updatedAt    DateTime                @updatedAt

  org       Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch    Branch?           @relation(fields: [branchId], references: [id], onDelete: Cascade)
  contracts ServiceContract[]
  documents Document[]

  @@index([orgId, isActive])
  @@index([branchId])
  @@map("service_providers")
}

model ServiceContract {
  id         String            @id @default(cuid())
  providerId String
  branchId   String?
  frequency  ContractFrequency
  amount     Decimal           @db.Decimal(12, 2)
  currency   String            @default("UGX")
  taxRate    Decimal?          @db.Decimal(5, 2)
  dueDay     Int? // Day of month (1-31) for MONTHLY, day of week (0-6) for WEEKLY
  startDate  DateTime          @db.Date
  endDate    DateTime?         @db.Date
  status     ContractStatus    @default(ACTIVE)
  glAccount  String?
  costCenter String?
  notes      String?
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt

  provider  ServiceProvider          @relation(fields: [providerId], references: [id], onDelete: Cascade)
  branch    Branch?                  @relation(fields: [branchId], references: [id], onDelete: Cascade)
  reminders ServicePayableReminder[]

  @@index([providerId, status])
  @@index([branchId, status])
  @@index([status, startDate, endDate])
  @@map("service_contracts")
}

model ServicePayableReminder {
  id               String           @id @default(cuid())
  contractId       String
  branchId         String?
  orgId            String
  dueDate          DateTime         @db.Date
  status           ReminderStatus   @default(PENDING)
  severity         ReminderSeverity
  acknowledgedById String?
  acknowledgedAt   DateTime?
  notes            String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  contract       ServiceContract @relation(fields: [contractId], references: [id], onDelete: Cascade)
  branch         Branch?         @relation(fields: [branchId], references: [id], onDelete: Cascade)
  org            Org             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  acknowledgedBy User?           @relation(fields: [acknowledgedById], references: [id], onDelete: SetNull)

  @@unique([contractId, dueDate, severity])
  @@index([orgId, status, severity])
  @@index([branchId, dueDate])
  @@index([dueDate, status])
  @@map("service_payable_reminders")
}

model OpsBudget {
  id             String         @id @default(cuid())
  branchId       String
  orgId          String
  year           Int
  month          Int // 1-12
  category       BudgetCategory
  budgetAmount   Decimal        @db.Decimal(12, 2)
  forecastAmount Decimal?       @db.Decimal(12, 2)
  actualAmount   Decimal        @default(0) @db.Decimal(12, 2)
  varianceAmount Decimal        @default(0) @db.Decimal(12, 2)
  variancePct    Decimal        @default(0) @db.Decimal(7, 2)
  notes          String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)
  org    Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([branchId, year, month, category])
  @@index([orgId, year, month])
  @@index([branchId, year, month])
  @@map("ops_budgets")
}

model CostInsight {
  id                String              @id @default(cuid())
  branchId          String
  orgId             String
  category          BudgetCategory
  severity          CostInsightSeverity
  reason            String
  suggestion        String
  supportingMetrics Json
  periodStart       DateTime            @db.Date
  periodEnd         DateTime            @db.Date
  createdAt         DateTime            @default(now())

  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)
  org    Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([orgId, createdAt])
  @@index([branchId, severity, createdAt])
  @@map("cost_insights")
}

// ===== M9.6: Branch Operating Hours =====

model BranchOperatingHours {
  id        String   @id @default(cuid())
  orgId     String
  branchId  String
  dayOfWeek Int // 0=Sunday, 6=Saturday
  openTime  String // "09:00" (24h format)
  closeTime String // "22:00" (24h format)
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org    Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@unique([branchId, dayOfWeek])
  @@index([orgId])
  @@index([branchId])
  @@map("branch_operating_hours")
}

// ===== M9.6: Branch Blackouts =====

model BranchBlackout {
  id        String   @id @default(cuid())
  orgId     String
  branchId  String
  title     String // "Private Event", "Maintenance", etc.
  startAt   DateTime
  endAt     DateTime
  reason    String?
  createdBy String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org    Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@index([branchId])
  @@index([startAt, endAt])
  @@map("branch_blackouts")
}

// ===== M9.6: Branch Capacity Rules =====

model BranchCapacityRule {
  id                String   @id @default(cuid())
  orgId             String
  branchId          String   @unique
  maxPartiesPerHour Int? // null = unlimited
  maxCoversPerHour  Int? // null = unlimited (covers = total guests)
  enabled           Boolean  @default(true)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  org    Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@index([orgId])
  @@map("branch_capacity_rules")
}

// ===== M9.6: OpsIncident =====

model OpsIncident {
  id                 String    @id @default(cuid())
  orgId              String
  branchId           String?
  type               String // "WEBHOOK_CIRCUIT_OPEN", "HOLD_EXPIRY_SPIKE", "MEAL_BREAK_MISSED", "MEAL_BREAK_SHORT", "REST_BREAK_MISSED", "REST_BREAK_SHORT"
  severity           String // "LOW", "MEDIUM", "HIGH", "CRITICAL"
  title              String
  payload            Json?
  resolved           Boolean   @default(false)
  resolvedAt         DateTime?
  resolvedBy         String?
  // M10.19: Compliance incident extensions
  timeEntryId        String? // Link to time entry for break incidents
  userId             String? // User involved in the incident
  incidentDate       DateTime? // Date of the incident
  penaltyMinutes     Int? // Penalty minutes for meal/rest break violations
  penaltyAmountCents Int? // Optional monetary penalty in cents
  currency           String?   @default("USD") // Currency code
  createdAt          DateTime  @default(now())

  org       Org        @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch    Branch?    @relation(fields: [branchId], references: [id], onDelete: Cascade)
  timeEntry TimeEntry? @relation(fields: [timeEntryId], references: [id], onDelete: Cascade)
  user      User?      @relation("ComplianceIncidents", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, timeEntryId, type]) // M10.19: Idempotency constraint
  @@index([orgId])
  @@index([branchId])
  @@index([type, createdAt])
  @@index([resolved, createdAt])
  @@index([userId, createdAt])
  @@index([timeEntryId])
  @@map("ops_incidents")
}

// ===== M9.5: Webhook Integration =====

model WebhookEndpoint {
  id                    String    @id @default(cuid())
  orgId                 String
  branchId              String?
  url                   String
  secret                String // HMAC secret (stored hashed in production)
  eventTypes            String[] // Array of event type strings
  enabled               Boolean   @default(true)
  maxRetries            Int       @default(3)
  timeoutMs             Int       @default(5000)
  // M9.6: Circuit breaker fields
  failureCount          Int       @default(0)
  disabledUntil         DateTime?
  lastFailureAt         DateTime?
  circuitBreakThreshold Int       @default(5)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  org        Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch     Branch?           @relation(fields: [branchId], references: [id], onDelete: Cascade)
  deliveries WebhookDelivery[]

  @@index([orgId])
  @@index([branchId])
  @@map("webhook_endpoints")
}

model WebhookDelivery {
  id            String                @id @default(cuid())
  endpointId    String
  eventType     String
  eventId       String                @unique // Idempotency key
  payload       Json
  status        WebhookDeliveryStatus @default(PENDING)
  attempts      Int                   @default(0)
  lastAttemptAt DateTime?
  responseCode  Int?
  responseBody  String? // Truncated to 1000 chars
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt

  endpoint WebhookEndpoint @relation(fields: [endpointId], references: [id], onDelete: Cascade)

  @@index([endpointId])
  @@index([status])
  @@index([eventId])
  @@map("webhook_deliveries")
}

// ===== M9.5: Notification Templates =====

model NotificationTemplate {
  id        String           @id @default(cuid())
  orgId     String
  branchId  String?
  type      NotificationType
  event     String // e.g., "reservation.confirmed"
  subject   String? // For email
  body      String // Template with {{variables}}
  enabled   Boolean          @default(true)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  org    Org     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch? @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@unique([orgId, branchId, type, event])
  @@index([orgId])
  @@map("notification_templates")
}

// ===== M9.5: Notification Outbox =====

model NotificationOutbox {
  id          String                   @id @default(cuid())
  orgId       String
  recipientId String? // User ID or external identifier
  type        NotificationType
  event       String
  subject     String?
  body        String // Rendered body
  status      NotificationOutboxStatus @default(PENDING)
  attempts    Int                      @default(0)
  lastError   String?
  metadata    Json? // Additional context
  createdAt   DateTime                 @default(now())
  updatedAt   DateTime                 @updatedAt

  org Org @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([orgId])
  @@map("notification_outbox")
}

// ===== M9.5: Calendar Feed Tokens =====

model CalendarFeedToken {
  id        String    @id @default(cuid())
  branchId  String
  token     String    @unique
  scope     String    @default("CALENDAR_READ")
  expiresAt DateTime?
  createdAt DateTime  @default(now())

  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@index([branchId])
  @@index([token])
  @@map("calendar_feed_tokens")
}

// ===== M10.3: Workforce Enterprise Controls =====

enum PayPeriodStatus {
  OPEN
  CLOSED
  EXPORTED
}

enum RoundingMode {
  NEAREST
  UP
  DOWN
}

enum TimesheetApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

// M10.5: Adjustment request status
enum AdjustmentStatus {
  REQUESTED
  APPROVED
  REJECTED
}

model WorkforcePolicy {
  id                           String       @id @default(cuid())
  orgId                        String       @unique
  dailyOtThresholdMins         Int          @default(480) // 8 hours
  weeklyOtThresholdMins        Int          @default(2400) // 40 hours
  roundingIntervalMins         Int          @default(15) // Round to 15-min blocks
  roundingMode                 RoundingMode @default(NEAREST)
  requireApproval              Boolean      @default(true)
  autoLockDays                 Int          @default(7) // Auto-lock after N days
  openShiftRequiresApproval    Boolean      @default(true) // M10.11: Require approval for open shift claims
  minRestHoursBetweenShifts    Int          @default(10) // M10.14: Minimum rest hours between shifts
  maxWeeklyHours               Int          @default(48) // M10.14: Maximum weekly hours
  maxConsecutiveDays           Int          @default(6) // M10.14: Maximum consecutive work days
  // M10.19: Break/Meal Compliance Rules
  mealBreakRequiredAfterHours  Int          @default(6) // Meal break required after X hours
  mealBreakMinimumMinutes      Int          @default(30) // Minimum meal break duration
  restBreakRequiredAfterHours  Int          @default(4) // Rest break required after X hours
  restBreakMinimumMinutes      Int          @default(10) // Minimum rest break duration
  allowWaiveMealBreak          Boolean      @default(false) // Allow employees to waive meal break
  // M10.21: Kiosk Timeclock Controls
  requireKioskForTimeclock     Boolean      @default(false) // Require kiosk for clock operations
  requireGeofenceForKiosk      Boolean      @default(false) // Apply geofence enforcement even for kiosk
  kioskPinRateLimitPerMinute   Int          @default(5) // Max PIN attempts per minute per device
  kioskSessionTimeoutMinutes   Int          @default(720) // 12 hours default session timeout
  // M10.22: Kiosk Ops Hardening
  kioskHeartbeatStaleSeconds   Int          @default(120) // 2 minutes before STALE status
  kioskHeartbeatOfflineSeconds Int          @default(900) // 15 minutes before OFFLINE status
  kioskMaxInvalidPinsPerMinute Int          @default(10) // Block after this many invalid PINs
  createdAt                    DateTime     @default(now())
  updatedAt                    DateTime     @updatedAt

  org Org @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@map("workforce_policies")
}

model PayPeriod {
  id           String          @id @default(cuid())
  orgId        String
  branchId     String? // NULL = org-wide
  periodType   String // WEEKLY, BIWEEKLY, MONTHLY
  startDate    DateTime        @db.Date
  endDate      DateTime        @db.Date
  status       PayPeriodStatus @default(OPEN)
  closedAt     DateTime?
  closedById   String?
  exportedAt   DateTime?
  exportedById String?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  org         Org          @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch      Branch?      @relation(fields: [branchId], references: [id], onDelete: SetNull)
  closedBy    User?        @relation("ClosedPayPeriods", fields: [closedById], references: [id])
  exportedBy  User?        @relation("ExportedPayPeriods", fields: [exportedById], references: [id])
  payrollRuns PayrollRun[] // M10.6: Payroll runs for this period

  @@unique([orgId, branchId, startDate, endDate])
  @@index([orgId, status])
  @@map("pay_periods")
}

model TimesheetApproval {
  id              String                  @id @default(cuid())
  timeEntryId     String                  @unique
  orgId           String
  status          TimesheetApprovalStatus @default(PENDING)
  approvedById    String?
  approvedAt      DateTime?
  rejectedById    String?
  rejectedAt      DateTime?
  rejectionReason String?
  lockedAt        DateTime? // Once locked, cannot be changed
  createdAt       DateTime                @default(now())
  updatedAt       DateTime                @updatedAt

  timeEntry  TimeEntry @relation(fields: [timeEntryId], references: [id], onDelete: Cascade)
  org        Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  approvedBy User?     @relation("ApprovedTimesheets", fields: [approvedById], references: [id])
  rejectedBy User?     @relation("RejectedTimesheets", fields: [rejectedById], references: [id])

  @@index([orgId, status])
  @@map("timesheet_approvals")
}

// M10.5: Timesheet Adjustment Workflow
model TimeEntryAdjustment {
  id               String           @id @default(cuid())
  orgId            String
  timeEntryId      String
  requestedById    String
  approvedById     String?
  status           AdjustmentStatus @default(REQUESTED)
  originalClockIn  DateTime?
  originalClockOut DateTime?
  newClockIn       DateTime?
  newClockOut      DateTime?
  reason           String
  rejectionReason  String?
  appliedAt        DateTime?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  org         Org       @relation(fields: [orgId], references: [id], onDelete: Cascade)
  timeEntry   TimeEntry @relation(fields: [timeEntryId], references: [id], onDelete: Cascade)
  requestedBy User      @relation("RequestedAdjustments", fields: [requestedById], references: [id])
  approvedBy  User?     @relation("ApprovedAdjustments", fields: [approvedById], references: [id])

  @@index([orgId, status])
  @@index([timeEntryId])
  @@map("time_entry_adjustments")
}

// M10.6: Payroll Run Status
enum PayrollRunStatus {
  DRAFT
  CALCULATED
  APPROVED
  POSTED
  PAID
  VOID
}

// M10.6: Payroll Run (batch payroll for a pay period)
model PayrollRun {
  id            String           @id @default(cuid())
  orgId         String
  branchId      String? // NULL = org-wide
  payPeriodId   String
  status        PayrollRunStatus @default(DRAFT)
  regularHours  Decimal          @default(0) @db.Decimal(10, 2)
  overtimeHours Decimal          @default(0) @db.Decimal(10, 2)
  breakHours    Decimal          @default(0) @db.Decimal(10, 2)
  paidHours     Decimal          @default(0) @db.Decimal(10, 2)
  grossAmount   Decimal?         @db.Decimal(12, 2) // If wage rates configured
  createdById   String
  calculatedAt  DateTime?
  approvedById  String?
  approvedAt    DateTime?
  postedById    String?
  postedAt      DateTime?
  paidById      String?
  paidAt        DateTime?
  voidedById    String?
  voidedAt      DateTime?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  org                  Org                     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch               Branch?                 @relation(fields: [branchId], references: [id], onDelete: SetNull)
  payPeriod            PayPeriod               @relation(fields: [payPeriodId], references: [id], onDelete: Restrict)
  createdBy            User                    @relation("CreatedPayrollRuns", fields: [createdById], references: [id])
  approvedBy           User?                   @relation("ApprovedPayrollRuns", fields: [approvedById], references: [id])
  postedBy             User?                   @relation("PostedPayrollRuns", fields: [postedById], references: [id])
  paidBy               User?                   @relation("PaidPayrollRuns", fields: [paidById], references: [id])
  voidedBy             User?                   @relation("VoidedPayrollRuns", fields: [voidedById], references: [id])
  lines                PayrollRunLine[]
  journalLinks         PayrollRunJournalLink[]
  payslips             Payslip[] // M10.7: Payslips generated from this run
  remittanceSourceLink RemittanceSourceLink? // M10.10: Link to generated remittance batch

  @@unique([payPeriodId, branchId])
  @@index([orgId, status])
  @@index([payPeriodId])
  @@map("payroll_runs")
}

// M10.6: Payroll Run Line Item (per employee)
model PayrollRunLine {
  id            String   @id @default(cuid())
  payrollRunId  String
  userId        String
  regularHours  Decimal  @default(0) @db.Decimal(10, 2)
  overtimeHours Decimal  @default(0) @db.Decimal(10, 2)
  breakHours    Decimal  @default(0) @db.Decimal(10, 2)
  paidHours     Decimal  @default(0) @db.Decimal(10, 2)
  hourlyRate    Decimal? @db.Decimal(8, 2)
  grossAmount   Decimal? @db.Decimal(12, 2)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  payrollRun PayrollRun @relation(fields: [payrollRunId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  payslip    Payslip? // M10.7: One-to-one with payslip

  @@unique([payrollRunId, userId])
  @@index([payrollRunId])
  @@map("payroll_run_lines")
}

// M10.6: Links payroll run to journal entries for traceability
model PayrollRunJournalLink {
  id             String   @id @default(cuid())
  payrollRunId   String
  journalEntryId String
  type           String // "ACCRUAL" or "PAYMENT"
  createdAt      DateTime @default(now())

  payrollRun   PayrollRun   @relation(fields: [payrollRunId], references: [id], onDelete: Cascade)
  journalEntry JournalEntry @relation(fields: [journalEntryId], references: [id], onDelete: Restrict)

  @@unique([payrollRunId, journalEntryId])
  @@index([payrollRunId])
  @@index([journalEntryId])
  @@map("payroll_run_journal_links")
}

// ===== M10.8: Payroll Posting Mapping (Configurable GL Accounts) =====

model PayrollPostingMapping {
  id       String  @id @default(cuid())
  orgId    String
  branchId String? // Optional for branch-specific overrides

  // Account mappings
  laborExpenseAccountId           String
  wagesPayableAccountId           String
  taxesPayableAccountId           String
  deductionsPayableAccountId      String
  employerContribExpenseAccountId String
  employerContribPayableAccountId String
  cashAccountId                   String

  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org    Org     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch? @relation(fields: [branchId], references: [id], onDelete: Cascade)

  // Account relations
  laborExpenseAccount           Account @relation("LaborExpenseAccount", fields: [laborExpenseAccountId], references: [id])
  wagesPayableAccount           Account @relation("WagesPayableAccount", fields: [wagesPayableAccountId], references: [id])
  taxesPayableAccount           Account @relation("TaxesPayableAccount", fields: [taxesPayableAccountId], references: [id])
  deductionsPayableAccount      Account @relation("DeductionsPayableAccount", fields: [deductionsPayableAccountId], references: [id])
  employerContribExpenseAccount Account @relation("EmployerContribExpenseAccount", fields: [employerContribExpenseAccountId], references: [id])
  employerContribPayableAccount Account @relation("EmployerContribPayableAccount", fields: [employerContribPayableAccountId], references: [id])
  cashAccount                   Account @relation("CashAccount", fields: [cashAccountId], references: [id])

  @@unique([orgId, branchId]) // One mapping per org+branch combo
  @@index([orgId])
  @@map("payroll_posting_mappings")
}

// ===== M10.9: Remittance Batches (Liability Settlements) =====
// ===== M10.10: Extended with Provider Directory + Reconciliation =====

enum RemittanceBatchStatus {
  DRAFT
  APPROVED
  POSTED
  PAID
  VOID
}

enum RemittanceBatchType {
  TAX
  DEDUCTION
  EMPLOYER_CONTRIB
  MIXED
}

// M10.10: Settlement method for reconciliation
enum SettlementMethod {
  CASH
  BANK_TRANSFER
  MOBILE_MONEY
  OTHER
}

// M10.10: Remittance provider type
enum RemittanceProviderType {
  TAX_AUTHORITY
  BENEFITS
  PENSION
  OTHER
}

// M10.10: Provider directory for remittance payees
model RemittanceProvider {
  id                        String                 @id @default(cuid())
  orgId                     String
  branchId                  String? // NULL = org-wide, set = branch-specific
  name                      String
  type                      RemittanceProviderType
  referenceFormatHint       String? // e.g., "TIN-XXXXXX"
  defaultLiabilityAccountId String?
  defaultCashAccountId      String?
  enabled                   Boolean                @default(true)
  createdAt                 DateTime               @default(now())
  updatedAt                 DateTime               @updatedAt

  org                     Org      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch                  Branch?  @relation(fields: [branchId], references: [id], onDelete: SetNull)
  defaultLiabilityAccount Account? @relation("ProviderLiabilityAccount", fields: [defaultLiabilityAccountId], references: [id])
  defaultCashAccount      Account? @relation("ProviderCashAccount", fields: [defaultCashAccountId], references: [id])

  componentMappings CompensationRemittanceMapping[]

  @@index([orgId])
  @@index([branchId])
  @@map("remittance_providers")
}

// M10.10: Mapping from compensation component to remittance provider
model CompensationRemittanceMapping {
  id             String              @id @default(cuid())
  orgId          String
  componentId    String
  providerId     String
  remittanceType RemittanceBatchType // TAX, DEDUCTION, EMPLOYER_CONTRIB
  createdAt      DateTime            @default(now())

  org       Org                   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  component CompensationComponent @relation(fields: [componentId], references: [id], onDelete: Cascade)
  provider  RemittanceProvider    @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@unique([componentId])
  @@index([orgId])
  @@index([providerId])
  @@map("compensation_remittance_mappings")
}

model RemittanceBatch {
  id             String                @id @default(cuid())
  orgId          String
  branchId       String? // NULL = org-wide
  status         RemittanceBatchStatus @default(DRAFT)
  type           RemittanceBatchType
  currencyCode   String                @default("UGX")
  periodId       String? // Optional link to FiscalPeriod
  idempotencyKey String? // Unique per org to prevent duplicates
  memo           String?
  totalAmount    Decimal               @default(0) @db.Decimal(12, 2)

  // M10.10: Reconciliation fields
  externalReference String? // Bank transfer reference, etc.
  settledAt         DateTime? // When actually paid externally
  settlementMethod  SettlementMethod? // How it was paid
  receiptNote       String? // Receipt or settlement note

  createdById  String
  approvedById String?
  approvedAt   DateTime?
  postedById   String?
  postedAt     DateTime?
  paidById     String?
  paidAt       DateTime?
  voidedById   String?
  voidedAt     DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  org        Org     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch     Branch? @relation(fields: [branchId], references: [id], onDelete: SetNull)
  createdBy  User    @relation("CreatedRemittanceBatches", fields: [createdById], references: [id])
  approvedBy User?   @relation("ApprovedRemittanceBatches", fields: [approvedById], references: [id])
  postedBy   User?   @relation("PostedRemittanceBatches", fields: [postedById], references: [id])
  paidBy     User?   @relation("PaidRemittanceBatches", fields: [paidById], references: [id])
  voidedBy   User?   @relation("VoidedRemittanceBatches", fields: [voidedById], references: [id])

  lines        RemittanceLine[]
  journalLinks RemittanceJournalLink[]
  sourceLinks  RemittanceSourceLink[] // M10.10: Links to source payroll runs

  @@unique([orgId, idempotencyKey])
  @@index([orgId, status])
  @@index([branchId])
  @@map("remittance_batches")
}

// M10.10: Link table to prevent duplicate generation from same payroll run
model RemittanceSourceLink {
  id           String   @id @default(cuid())
  batchId      String
  payrollRunId String
  createdAt    DateTime @default(now())

  batch      RemittanceBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  payrollRun PayrollRun      @relation(fields: [payrollRunId], references: [id], onDelete: Cascade)

  @@unique([payrollRunId]) // A payroll run can only be linked to ONE batch
  @@index([batchId])
  @@map("remittance_source_links")
}

model RemittanceLine {
  id                 String   @id @default(cuid())
  batchId            String
  componentId        String? // Optional link to CompensationComponent
  liabilityAccountId String // GL account being settled (e.g., Taxes Payable)
  counterAccountId   String // Cash/bank account for payment
  amount             Decimal  @db.Decimal(12, 2)
  payeeName          String? // Name of tax authority/benefits provider
  referenceCode      String? // External reference (e.g., tax filing ID)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  batch            RemittanceBatch        @relation(fields: [batchId], references: [id], onDelete: Cascade)
  component        CompensationComponent? @relation(fields: [componentId], references: [id], onDelete: SetNull)
  liabilityAccount Account                @relation("RemittanceLiabilityAccount", fields: [liabilityAccountId], references: [id])
  counterAccount   Account                @relation("RemittanceCounterAccount", fields: [counterAccountId], references: [id])

  @@index([batchId])
  @@index([componentId])
  @@map("remittance_lines")
}

model RemittanceJournalLink {
  id             String   @id @default(cuid())
  batchId        String
  journalEntryId String
  type           String // "PAYMENT" or "REVERSAL"
  createdAt      DateTime @default(now())

  batch        RemittanceBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  journalEntry JournalEntry    @relation(fields: [journalEntryId], references: [id], onDelete: Restrict)

  @@unique([batchId, journalEntryId])
  @@index([batchId])
  @@index([journalEntryId])
  @@map("remittance_journal_links")
}

// ===== M10.7: Compensation Components & Payslips =====

enum CompensationComponentType {
  EARNING
  DEDUCTION_PRE
  DEDUCTION_POST
  TAX
  EMPLOYER_CONTRIB
}

enum CalcMethod {
  FIXED
  PERCENT_OF_GROSS
  PERCENT_OF_EARNINGS_CODE
  PER_HOUR
}

enum RoundingRule {
  HALF_UP_CENTS
  HALF_UP_UNIT
}

// M10.7: Org-scoped compensation component definitions
model CompensationComponent {
  id           String                    @id @default(cuid())
  orgId        String
  branchId     String? // NULL = org-level, set = branch override
  code         String
  name         String
  type         CompensationComponentType
  calcMethod   CalcMethod
  rate         Decimal                   @default(0) @db.Decimal(10, 4)
  amount       Decimal                   @default(0) @db.Decimal(12, 2)
  earningsCode String? // For PERCENT_OF_EARNINGS_CODE method
  capMin       Decimal?                  @db.Decimal(12, 2)
  capMax       Decimal?                  @db.Decimal(12, 2)
  roundingRule RoundingRule              @default(HALF_UP_CENTS)
  enabled      Boolean                   @default(true)
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt

  org                Org                             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch             Branch?                         @relation(fields: [branchId], references: [id], onDelete: SetNull)
  employeeComponents EmployeeCompensationComponent[]
  payslipLineItems   PayslipLineItem[]
  remittanceLines    RemittanceLine[] // M10.9: Remittance lines linked to this component
  remittanceMapping  CompensationRemittanceMapping? // M10.10: Provider mapping

  @@unique([orgId, code, branchId])
  @@index([orgId, enabled])
  @@index([branchId])
  @@map("compensation_components")
}

// M10.7: Employee compensation profile with effective dates
model EmployeeCompensationProfile {
  id        String    @id @default(cuid())
  orgId     String
  userId    String
  startDate DateTime
  endDate   DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  org        Org                             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user       User                            @relation(fields: [userId], references: [id], onDelete: Cascade)
  components EmployeeCompensationComponent[]

  @@index([orgId, userId])
  @@index([userId, startDate])
  @@map("employee_compensation_profiles")
}

// M10.7: Component assignment to employee profile
model EmployeeCompensationComponent {
  id             String   @id @default(cuid())
  profileId      String
  componentId    String
  overrideRate   Decimal? @db.Decimal(10, 4)
  overrideAmount Decimal? @db.Decimal(12, 2)

  profile   EmployeeCompensationProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  component CompensationComponent       @relation(fields: [componentId], references: [id], onDelete: Cascade)

  @@unique([profileId, componentId])
  @@map("employee_compensation_components")
}

// M10.7: Payslip generated from payroll run line
model Payslip {
  id                   String   @id @default(cuid())
  orgId                String
  payrollRunId         String
  payrollRunLineId     String   @unique
  userId               String
  payPeriodStart       DateTime
  payPeriodEnd         DateTime
  grossEarnings        Decimal  @db.Decimal(12, 2)
  preTaxDeductions     Decimal  @db.Decimal(12, 2)
  taxableWages         Decimal  @db.Decimal(12, 2)
  taxesWithheld        Decimal  @db.Decimal(12, 2)
  postTaxDeductions    Decimal  @db.Decimal(12, 2)
  netPay               Decimal  @db.Decimal(12, 2)
  employerContribTotal Decimal  @db.Decimal(12, 2)
  totalEmployerCost    Decimal  @db.Decimal(12, 2)
  createdAt            DateTime @default(now())

  org            Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)
  payrollRun     PayrollRun        @relation(fields: [payrollRunId], references: [id], onDelete: Cascade)
  payrollRunLine PayrollRunLine    @relation(fields: [payrollRunLineId], references: [id], onDelete: Cascade)
  user           User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  lineItems      PayslipLineItem[]

  @@index([orgId, userId])
  @@index([payrollRunId])
  @@map("payslips")
}

// M10.7: Payslip breakdown line item
model PayslipLineItem {
  id            String                    @id @default(cuid())
  payslipId     String
  componentId   String
  componentCode String
  componentName String
  type          CompensationComponentType
  amount        Decimal                   @db.Decimal(12, 2)

  payslip   Payslip               @relation(fields: [payslipId], references: [id], onDelete: Cascade)
  component CompensationComponent @relation(fields: [componentId], references: [id], onDelete: Restrict)

  @@index([payslipId])
  @@map("payslip_line_items")
}

// ===== M10.11: Workforce Availability + Shift Swaps + Open Shifts =====

// M10.11: Weekly recurring availability per user
model WorkforceAvailability {
  id        String   @id @default(cuid())
  orgId     String
  userId    String
  dayOfWeek Int // 0=Sunday, 6=Saturday
  startTime String // HH:MM format
  endTime   String // HH:MM format
  timezone  String? // Optional timezone override
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  org  Org  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, dayOfWeek, startTime])
  @@index([orgId])
  @@index([userId])
  @@map("workforce_availability")
}

// M10.11: Date-based availability exceptions
model WorkforceAvailabilityException {
  id          String   @id @default(cuid())
  orgId       String
  userId      String
  date        DateTime @db.Date
  isAvailable Boolean  @default(false)
  startTime   String? // HH:MM if available
  endTime     String? // HH:MM if available
  reason      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  org  Org  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([orgId])
  @@index([userId])
  @@map("workforce_availability_exceptions")
}

// M10.11: Enhanced shift swap request with lifecycle
model ShiftSwapRequest {
  id               String                 @id @default(cuid())
  orgId            String
  branchId         String
  type             ShiftSwapRequestType
  status           ShiftSwapRequestStatus @default(DRAFT)
  requesterId      String
  requesterShiftId String
  targetUserId     String? // For DIRECT_SWAP
  targetShiftId    String? // For DIRECT_SWAP
  claimerId        String? // For OFFER_SHIFT when claimed
  reason           String?
  declineReason    String?
  rejectReason     String?
  requestedAt      DateTime?
  acceptedAt       DateTime?
  declinedAt       DateTime?
  approvedAt       DateTime?
  approvedById     String?
  rejectedAt       DateTime?
  rejectedById     String?
  appliedAt        DateTime?
  cancelledAt      DateTime?
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt

  org            Org             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch         Branch          @relation(fields: [branchId], references: [id], onDelete: Cascade)
  requester      User            @relation("SwapRequester", fields: [requesterId], references: [id], onDelete: Cascade)
  requesterShift ScheduledShift  @relation("RequesterShift", fields: [requesterShiftId], references: [id], onDelete: Cascade)
  targetUser     User?           @relation("SwapTarget", fields: [targetUserId], references: [id], onDelete: SetNull)
  targetShift    ScheduledShift? @relation("TargetShift", fields: [targetShiftId], references: [id], onDelete: SetNull)
  claimer        User?           @relation("SwapClaimer", fields: [claimerId], references: [id], onDelete: SetNull)
  approvedBy     User?           @relation("SwapApprover", fields: [approvedById], references: [id], onDelete: SetNull)
  rejectedBy     User?           @relation("SwapRejecter", fields: [rejectedById], references: [id], onDelete: SetNull)

  @@index([orgId])
  @@index([branchId])
  @@index([requesterId])
  @@index([targetUserId])
  @@index([status])
  @@map("shift_swap_requests")
}

// M10.11: Open shift claims
model OpenShiftClaim {
  id           String    @id @default(cuid())
  orgId        String
  shiftId      String
  claimerId    String
  status       String    @default("PENDING") // PENDING, APPROVED, REJECTED, WITHDRAWN
  approvedById String?
  approvedAt   DateTime?
  rejectedById String?
  rejectedAt   DateTime?
  rejectReason String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  org        Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  shift      ScheduledShift @relation(fields: [shiftId], references: [id], onDelete: Cascade)
  claimer    User           @relation("ShiftClaimant", fields: [claimerId], references: [id], onDelete: Cascade)
  approvedBy User?          @relation("ClaimApprover", fields: [approvedById], references: [id], onDelete: SetNull)
  rejectedBy User?          @relation("ClaimRejecter", fields: [rejectedById], references: [id], onDelete: SetNull)

  @@unique([shiftId, claimerId])
  @@index([orgId])
  @@index([shiftId])
  @@index([claimerId])
  @@map("open_shift_claims")
}

// M10.11: Workforce notification log
model WorkforceNotificationLog {
  id            String                    @id @default(cuid())
  orgId         String
  type          WorkforceNotificationType
  targetUserId  String
  performedById String?
  entityType    String // SwapRequest, OpenShift, Availability
  entityId      String
  payload       Json?
  readAt        DateTime?
  createdAt     DateTime                  @default(now())

  org         Org   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  targetUser  User  @relation("NotificationTarget", fields: [targetUserId], references: [id], onDelete: Cascade)
  performedBy User? @relation("NotificationPerformer", fields: [performedById], references: [id], onDelete: SetNull)

  @@index([orgId])
  @@index([targetUserId])
  @@index([type])
  @@map("workforce_notification_logs")
}

// ===== M10.12: Labor Forecasting + Staffing Planner =====

enum StaffingPlanStatus {
  DRAFT
  PUBLISHED
}

enum AlertSeverity {
  LOW
  MEDIUM
  HIGH
}

enum StaffingAlertType {
  UNDERSTAFFED
  OVERSTAFFED
}

// M10.12: Labor targets configuration
model LaborTarget {
  id                   String   @id @default(cuid())
  orgId                String
  branchId             String? // null = org-level default; branch-level overrides org-level
  roleKey              String // jobRole slug (e.g., "WAITER", "COOK", "BARTENDER")
  dayOfWeek            Int // 0=Sunday..6=Saturday
  hourStart            Int // 0..23
  hourEnd              Int // 0..24 (exclusive)
  targetCoversPerStaff Int? // e.g., 20 covers per waiter per hour
  targetLaborPct       Decimal? @db.Decimal(5, 2) // e.g., 30% of hourly revenue
  enabled              Boolean  @default(true)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  org    Org     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch? @relation(fields: [branchId], references: [id], onDelete: Cascade)

  @@unique([orgId, branchId, roleKey, dayOfWeek, hourStart])
  @@index([orgId, branchId])
  @@map("labor_targets")
}

// M10.12: Labor forecast snapshot (point-in-time demand forecast)
model LaborForecastSnapshot {
  id          String   @id @default(cuid())
  orgId       String
  branchId    String
  date        DateTime @db.Date
  timezone    String   @default("UTC")
  inputsHash  String // sha256 of sorted inputs JSON for idempotency
  generatedAt DateTime @default(now())
  totalsJson  Json // { coversForecast: number[], ordersForecast: number[], dataSources: string[] }
  createdAt   DateTime @default(now())

  org           Org            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch        Branch         @relation(fields: [branchId], references: [id], onDelete: Cascade)
  staffingPlans StaffingPlan[]

  @@unique([orgId, branchId, date, inputsHash])
  @@index([orgId, branchId, date])
  @@map("labor_forecast_snapshots")
}

// M10.12: Staffing plan (generated staffing recommendations)
model StaffingPlan {
  id                 String             @id @default(cuid())
  orgId              String
  branchId           String
  date               DateTime           @db.Date
  timezone           String             @default("UTC")
  forecastSnapshotId String
  status             StaffingPlanStatus @default(DRAFT)
  generatedAt        DateTime           @default(now())
  publishedAt        DateTime?
  publishedById      String?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  org              Org                   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch           Branch                @relation(fields: [branchId], references: [id], onDelete: Cascade)
  forecastSnapshot LaborForecastSnapshot @relation(fields: [forecastSnapshotId], references: [id], onDelete: Cascade)
  publishedBy      User?                 @relation("PlanPublisher", fields: [publishedById], references: [id], onDelete: SetNull)
  lines            StaffingPlanLine[]
  // M10.13: Auto-Scheduler
  autoScheduleRuns AutoScheduleRun[]

  @@unique([orgId, branchId, date, forecastSnapshotId])
  @@index([orgId, branchId, date])
  @@index([status])
  @@map("staffing_plans")
}

// M10.12: Staffing plan lines (hourly role headcount)
model StaffingPlanLine {
  id                 String @id @default(cuid())
  staffingPlanId     String
  hour               Int // 0..23
  roleKey            String
  suggestedHeadcount Int
  rationale          Json? // { basedOn: 'covers', targetValue: 20, forecastedCovers: 80 }

  staffingPlan StaffingPlan @relation(fields: [staffingPlanId], references: [id], onDelete: Cascade)

  @@index([staffingPlanId])
  @@map("staffing_plan_lines")
}

// M10.12: Staffing alerts (under/over staffing warnings)
model StaffingAlert {
  id           String            @id @default(cuid())
  orgId        String
  branchId     String
  date         DateTime          @db.Date
  hour         Int // 0..23
  severity     AlertSeverity
  type         StaffingAlertType
  payloadJson  Json // { scheduledCount, suggestedCount, delta, roleKey }
  resolvedAt   DateTime?
  resolvedById String?
  createdAt    DateTime          @default(now())

  org        Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch     Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)
  resolvedBy User?  @relation("AlertResolver", fields: [resolvedById], references: [id], onDelete: SetNull)

  @@unique([orgId, branchId, date, hour, type])
  @@index([orgId, branchId, date])
  @@index([resolvedAt])
  @@map("staffing_alerts")
}

// ===== M10.13: Auto-Scheduler (Generate Shifts from Staffing Plan) =====

enum AutoScheduleRunStatus {
  DRAFT
  APPLIED
  VOID
}

// M10.13: Auto-schedule run (represents one generation attempt)
model AutoScheduleRun {
  id               String                @id @default(cuid())
  orgId            String
  branchId         String
  date             DateTime              @db.Date
  timezone         String
  staffingPlanId   String
  inputsHash       String // SHA256 of canonicalized inputs for idempotency
  algorithmVersion String                @default("v1.0")
  status           AutoScheduleRunStatus @default(DRAFT)
  assignmentMode   String                @default("UNASSIGNED") // M10.14: UNASSIGNED | ASSIGNED
  generatedAt      DateTime              @default(now())
  appliedAt        DateTime?
  appliedById      String?
  publishedAt      DateTime? // M10.14: When schedule was published
  publishedById    String? // M10.14: Who published the schedule
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt

  org          Org                      @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch       Branch                   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  staffingPlan StaffingPlan             @relation(fields: [staffingPlanId], references: [id], onDelete: Cascade)
  appliedBy    User?                    @relation("RunApplier", fields: [appliedById], references: [id], onDelete: SetNull)
  publishedBy  User?                    @relation("RunPublisher", fields: [publishedById], references: [id], onDelete: SetNull)
  suggestions  AutoScheduleSuggestion[]

  @@unique([orgId, branchId, date, inputsHash])
  @@index([orgId, branchId, date])
  @@index([status])
  @@map("auto_schedule_runs")
}

// M10.13: Auto-schedule suggestion (shift block with candidates)
model AutoScheduleSuggestion {
  id               String   @id @default(cuid())
  runId            String
  roleKey          String
  startAt          DateTime
  endAt            DateTime
  headcount        Int
  candidateUserIds Json? // string[] of user IDs who are available
  score            Int? // optional priority score
  assignedUserId   String? // M10.14: Deterministically assigned user ID
  assignmentReason String? // M10.14: Why this user was assigned or constraint reason
  assignmentScore  Int? // M10.14: Assignment score for ranking
  createdAt        DateTime @default(now())

  run          AutoScheduleRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  assignedUser User?           @relation("SuggestionAssignee", fields: [assignedUserId], references: [id], onDelete: SetNull)

  @@index([runId, roleKey])
  @@map("auto_schedule_suggestions")
}

// ===== M10.21: Kiosk Device Enrollment =====

model KioskDevice {
  id             String    @id @default(cuid())
  orgId          String
  branchId       String
  name           String // "Front Entrance Tablet"
  publicId       String    @unique @db.VarChar(32) // Short public identifier for URL
  secretHash     String // Argon2id hash of device secret
  enabled        Boolean   @default(true)
  allowedIpCidrs String[]  @default([]) // Optional IP allowlist
  lastSeenAt     DateTime?
  createdById    String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  org          Org                  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch       Branch               @relation(fields: [branchId], references: [id], onDelete: Cascade)
  createdBy    User?                @relation("KioskDeviceCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  sessions     KioskDeviceSession[]
  pinAttempts  KioskPinAttempt[]
  clockEvents  KioskClockEvent[]
  events       KioskEvent[]         @relation("KioskEventDevice") // M10.22
  eventIngests KioskEventIngest[]   @relation("KioskEventIngestDevice") // M10.22

  @@index([orgId])
  @@index([branchId])
  @@index([publicId])
  @@map("kiosk_devices")
}

// ===== M10.21: Kiosk Device Sessions =====

model KioskDeviceSession {
  id              String    @id @default(cuid())
  kioskDeviceId   String
  startedAt       DateTime  @default(now())
  endedAt         DateTime?
  endedReason     String? // EXPIRED, ROTATED, MANUAL, HEARTBEAT_TIMEOUT
  lastHeartbeatAt DateTime  @default(now())
  ipAddress       String?
  userAgent       String?
  metadata        Json?

  kioskDevice KioskDevice @relation(fields: [kioskDeviceId], references: [id], onDelete: Cascade)

  @@index([kioskDeviceId])
  @@index([startedAt])
  @@map("kiosk_device_sessions")
}

// ===== M10.21: Kiosk PIN Attempts (Rate Limiting) =====

model KioskPinAttempt {
  id            String   @id @default(cuid())
  orgId         String
  branchId      String
  kioskDeviceId String
  pinMasked     String // Last 2 chars only (e.g., "**34")
  success       Boolean
  userId        String? // Only set if successful
  ipAddress     String?
  attemptedAt   DateTime @default(now())

  org         Org         @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch      Branch      @relation(fields: [branchId], references: [id], onDelete: Cascade)
  kioskDevice KioskDevice @relation(fields: [kioskDeviceId], references: [id], onDelete: Cascade)
  user        User?       @relation("KioskPinAttemptUser", fields: [userId], references: [id], onDelete: SetNull)

  @@index([orgId, kioskDeviceId, attemptedAt])
  @@index([kioskDeviceId, attemptedAt])
  @@map("kiosk_pin_attempts")
}

// ===== M10.21: Kiosk Clock Events =====

model KioskClockEvent {
  id            String   @id @default(cuid())
  orgId         String
  branchId      String
  kioskDeviceId String
  userId        String
  eventType     String // CLOCK_IN, CLOCK_OUT, BREAK_START, BREAK_END
  timeEntryId   String?
  breakEntryId  String?
  geoBlocked    Boolean  @default(false)
  geoOverridden Boolean  @default(false)
  ipAddress     String?
  createdAt     DateTime @default(now())

  org         Org         @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch      Branch      @relation(fields: [branchId], references: [id], onDelete: Cascade)
  kioskDevice KioskDevice @relation(fields: [kioskDeviceId], references: [id], onDelete: Cascade)
  user        User        @relation("KioskClockEventUser", fields: [userId], references: [id], onDelete: Cascade)

  @@index([orgId, branchId, createdAt])
  @@index([kioskDeviceId, createdAt])
  @@index([userId, createdAt])
  @@map("kiosk_clock_events")
}

// ===== M10.22: Kiosk Event (Batch Ingest + Idempotency) =====

model KioskEvent {
  id             String   @id @default(cuid())
  orgId          String
  branchId       String
  kioskDeviceId  String
  type           String // CLOCK_IN, CLOCK_OUT, BREAK_START, BREAK_END
  occurredAt     DateTime // Client event time
  receivedAt     DateTime @default(now()) // Server receive time
  idempotencyKey String // Client-generated unique key
  payloadJson    Json? // Sanitized payload (no secrets)
  status         String // ACCEPTED, REJECTED
  rejectCode     String? // INVALID_PIN, OUTSIDE_GEOFENCE, DEVICE_DISABLED, SEQUENCE_VIOLATION, etc.
  timeEntryId    String? // Linked time entry if created
  breakEntryId   String? // Linked break entry if created
  userId         String? // Resolved user from PIN

  org         Org         @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch      Branch      @relation(fields: [branchId], references: [id], onDelete: Cascade)
  kioskDevice KioskDevice @relation("KioskEventDevice", fields: [kioskDeviceId], references: [id], onDelete: Cascade)
  user        User?       @relation("KioskEventUser", fields: [userId], references: [id], onDelete: SetNull)

  @@unique([kioskDeviceId, idempotencyKey])
  @@index([orgId, branchId, receivedAt])
  @@index([kioskDeviceId, receivedAt])
  @@map("kiosk_events")
}

// ===== M10.22: Kiosk Event Ingest Batch =====

model KioskEventIngest {
  id            String   @id @default(cuid())
  kioskDeviceId String
  batchId       String // Client-provided batch ID
  eventCount    Int
  acceptedCount Int      @default(0)
  rejectedCount Int      @default(0)
  status        String // RECEIVED, PROCESSED
  diagnostics   String? // Truncated diagnostic info
  createdAt     DateTime @default(now())

  kioskDevice KioskDevice @relation("KioskEventIngestDevice", fields: [kioskDeviceId], references: [id], onDelete: Cascade)

  @@unique([kioskDeviceId, batchId])
  @@index([kioskDeviceId, createdAt])
  @@map("kiosk_event_ingests")
}

// ===== M11.1: Inventory Foundation =====

// Unit of Measure - org-scoped UOM definitions
model UnitOfMeasure {
  id         String   @id @default(cuid())
  orgId      String
  code       String // kg, g, L, mL, pcs, etc.
  name       String // Kilogram, Gram, Liter, etc.
  symbol     String? // Optional display symbol
  baseUnitId String? // Reference to base unit for conversions (null = IS base unit)
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  baseUnit                 UnitOfMeasure?        @relation("UomToBase", fields: [baseUnitId], references: [id], onDelete: SetNull)
  derivedUnits             UnitOfMeasure[]       @relation("UomToBase")
  conversionsFrom          UnitConversion[]      @relation("ConversionFrom")
  conversionsTo            UnitConversion[]      @relation("ConversionTo")
  inventoryItems           InventoryItem[]       @relation("ItemUom")
  // M11.2: Purchasing & Receiving
  poLinesV2Input           PurchaseOrderLineV2[] @relation("POLineInputUom")
  receiptLinesV2Input      GoodsReceiptLineV2[]  @relation("ReceiptLineInputUom")
  // M11.4: Recipes
  recipeOutputUom          Recipe[]              @relation("RecipeOutputUom")
  recipeLineInputUom       RecipeLine[]          @relation("RecipeLineInputUom")
  // M11.6: Supplier Catalog
  supplierItemVendorUom    SupplierItem[]        @relation("SupplierItemVendorUom")
  // M11.8: Vendor Returns
  vendorReturnLines        VendorReturnLine[]    @relation("VendorReturnLineUOM")
  // M11.9: Production Batches
  productionBatchOutputUom ProductionBatch[]     @relation("ProductionBatchOutputUom")
  productionBatchLineUom   ProductionBatchLine[] @relation("ProductionLineUom")
  // M80: Prep Items
  prepItemYieldUom         PrepItem[]            @relation("PrepItemYieldUom")
  prepLineUom              PrepLine[]            @relation("PrepLineUom")

  @@unique([orgId, code])
  @@index([orgId])
  @@map("units_of_measure")
}

// Unit Conversion - conversion factors between UOMs
model UnitConversion {
  id        String   @id @default(cuid())
  orgId     String
  fromUomId String
  toUomId   String
  factor    Decimal  @db.Decimal(18, 8) // Conversion factor: 1 fromUom = factor toUom
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  fromUom UnitOfMeasure @relation("ConversionFrom", fields: [fromUomId], references: [id], onDelete: Cascade)
  toUom   UnitOfMeasure @relation("ConversionTo", fields: [toUomId], references: [id], onDelete: Cascade)

  @@unique([orgId, fromUomId, toUomId])
  @@index([orgId])
  @@map("unit_conversions")
}

// Inventory Location - warehouse/storage locations per branch
model InventoryLocation {
  id           String   @id @default(cuid())
  orgId        String
  branchId     String
  code         String // MAIN, COLD, DRY, BAR, KITCHEN, etc.
  name         String // Main Storage, Cold Room, Dry Storage, Kitchen, etc.
  parentId     String? // Optional parent location for hierarchy
  locationType String? // STORAGE, PRODUCTION, RECEIVING, etc.
  isActive     Boolean  @default(true)
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  branch                   Branch                    @relation(fields: [branchId], references: [id], onDelete: Cascade)
  parent                   InventoryLocation?        @relation("LocationHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children                 InventoryLocation[]       @relation("LocationHierarchy")
  ledgerEntries            InventoryLedgerEntry[]
  adjustments              StockAdjustment[]
  countLines               CountSessionLine[]
  countSessions            CountSession[]            @relation("CountSessionLocation")
  // M11.2: Purchasing & Receiving
  receiptLinesV2           GoodsReceiptLineV2[]      @relation("ReceiptLineLocation")
  // M11.3: Transfers + Waste
  transferLinesFrom        InventoryTransferLine[]   @relation("TransferLineFromLocation")
  transferLinesTo          InventoryTransferLine[]   @relation("TransferLineToLocation")
  wasteLines               InventoryWasteLine[]      @relation("WasteLineLocation")
  // M11.4: Depletion + Recipes
  branchesDefaultDepletion Branch[]                  @relation("BranchDepletionLocation")
  depletions               OrderInventoryDepletion[] @relation("DepletionLocation")
  // M11.5: Costing + Valuation + COGS
  costLayers               InventoryCostLayer[]      @relation("CostLayerLocation")
  // M11.7: Lots
  inventoryLots            InventoryLot[]            @relation("LotLocation")
  // M11.8: Vendor Return Lines
  vendorReturnLines        VendorReturnLine[]        @relation("VendorReturnLineLocation")
  // M11.9: Production Batches
  productionBatches        ProductionBatch[]         @relation("ProductionBatchLocation")
  productionBatchLines     ProductionBatchLine[]     @relation("ProductionLineLocation")
  // M11.10: Stocktake Sessions v2
  stocktakeSessions        StocktakeSession[]        @relation("StocktakeSessionLocation")
  stocktakeLines           StocktakeLine[]           @relation("StocktakeLineLocation")
  // M12.1: Valuation Snapshots
  valuationSnapshots       InventoryValuationSnapshot[] @relation("ValuationSnapshotLocation")

  @@unique([branchId, code])
  @@index([orgId])
  @@index([branchId])
  @@map("inventory_locations")
}

// Append-Only Stock Ledger - IMMUTABLE ledger for all inventory movements
model InventoryLedgerEntry {
  id          String   @id @default(cuid())
  orgId       String
  branchId    String
  itemId      String
  locationId  String
  qty         Decimal  @db.Decimal(12, 4) // Positive = add, Negative = subtract
  reason      String // PURCHASE, SALE, WASTAGE, ADJUSTMENT, COUNT_ADJUSTMENT, TRANSFER_IN, TRANSFER_OUT
  sourceType  String // GOODS_RECEIPT, ORDER, WASTAGE, STOCK_ADJUSTMENT, COUNT_SESSION, TRANSFER
  sourceId    String? // ID of the source record
  notes       String?
  createdById String?
  metadata    Json?
  createdAt   DateTime @default(now()) // NEVER updated after creation
  // M12.3: Business event date (when the transaction occurred) - may differ from createdAt for backdated postings
  effectiveAt DateTime @default(now())

  branch    Branch            @relation(fields: [branchId], references: [id], onDelete: Cascade)
  item      InventoryItem     @relation(fields: [itemId], references: [id], onDelete: Restrict)
  location  InventoryLocation @relation(fields: [locationId], references: [id], onDelete: Restrict)
  createdBy User?             @relation("LedgerEntryCreator", fields: [createdById], references: [id], onDelete: SetNull)

  // M11.7: Lot allocation tracking
  lotAllocations        LotLedgerAllocation[]
  // M11.10: Stocktake linkage (for variance + reversal entries)
  stocktakeLinePosted   StocktakeLine?        @relation("StocktakeLedgerEntry")
  stocktakeLineReversal StocktakeLine?        @relation("StocktakeReversalEntry")

  @@index([orgId, branchId, itemId])
  @@index([itemId, locationId])
  @@index([sourceType, sourceId])
  @@index([createdAt])
  @@index([branchId, createdAt]) // M11.15: Branch-level time-series queries
  @@index([effectiveAt]) // M12.3: Period boundary queries
  @@index([branchId, effectiveAt]) // M12.3: Branch period queries
  @@index([orgId, branchId, effectiveAt]) // M12.3: Org+branch period queries
  @@map("inventory_ledger_entries")
}

// Stock Adjustment - explicit adjustment records
model StockAdjustment {
  id           String    @id @default(cuid())
  orgId        String
  branchId     String
  itemId       String
  locationId   String
  qty          Decimal   @db.Decimal(12, 4) // Can be positive or negative
  reason       String // DAMAGED, EXPIRED, THEFT, FOUND, CORRECTION, OTHER
  notes        String?
  createdById  String
  approvedById String?
  approvedAt   DateTime?
  status       String    @default("PENDING") // PENDING, APPROVED, REJECTED
  metadata     Json?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  branch     Branch            @relation(fields: [branchId], references: [id], onDelete: Cascade)
  item       InventoryItem     @relation("StockAdjustmentItem", fields: [itemId], references: [id], onDelete: Restrict)
  location   InventoryLocation @relation(fields: [locationId], references: [id], onDelete: Restrict)
  createdBy  User              @relation("StockAdjustmentCreator", fields: [createdById], references: [id], onDelete: Restrict)
  approvedBy User?             @relation("StockAdjustmentApprover", fields: [approvedById], references: [id], onDelete: SetNull)

  @@index([orgId, branchId])
  @@index([itemId])
  @@index([status])
  @@map("stock_adjustments")
}

// Count Session - cycle count sessions
model CountSession {
  id            String    @id @default(cuid())
  orgId         String
  branchId      String
  name          String? // Optional name like "Q1 Full Count"
  description   String? // Optional description
  locationId    String? // Optional: scope to specific location
  status        String    @default("OPEN") // OPEN, FINALIZED, CANCELLED
  createdById   String // Renamed from startedById for consistency
  finalizedById String?
  finalizedAt   DateTime?
  cancelledAt   DateTime?
  metadata      Json?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  branch      Branch             @relation(fields: [branchId], references: [id], onDelete: Cascade)
  location    InventoryLocation? @relation("CountSessionLocation", fields: [locationId], references: [id], onDelete: SetNull)
  createdBy   User               @relation("CountSessionCreator", fields: [createdById], references: [id], onDelete: Restrict)
  finalizedBy User?              @relation("CountSessionFinalizer", fields: [finalizedById], references: [id], onDelete: SetNull)
  lines       CountSessionLine[]

  @@index([orgId, branchId])
  @@index([status])
  @@map("count_sessions")
}

// Count Session Line - individual count entries
model CountSessionLine {
  id          String   @id @default(cuid())
  sessionId   String
  itemId      String
  locationId  String
  expectedQty Decimal  @db.Decimal(12, 4) // System on-hand at time of count
  countedQty  Decimal  @db.Decimal(12, 4) // The counted quantity
  variance    Decimal  @db.Decimal(12, 4) // countedQty - expectedQty
  notes       String?
  countedById String?
  countedAt   DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  session   CountSession      @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  item      InventoryItem     @relation("CountSessionLineItem", fields: [itemId], references: [id], onDelete: Restrict)
  location  InventoryLocation @relation(fields: [locationId], references: [id], onDelete: Restrict)
  countedBy User?             @relation("CountSessionLineCounter", fields: [countedById], references: [id], onDelete: SetNull)

  @@unique([sessionId, itemId, locationId])
  @@index([sessionId])
  @@index([itemId])
  @@map("count_session_lines")
}

// ============================================
// M11.10 Stocktake v2 - Enterprise Count Sessions
// ============================================

// Stocktake Session - enterprise-grade inventory count with workflow
model StocktakeSession {
  id                   String           @id @default(cuid())
  orgId                String
  branchId             String
  sessionNumber        String // Auto-generated: ST-YYYYMMDD-NNN
  name                 String? // Optional: "Q1 Full Count", "Month-End Count"
  description          String?
  locationId           String? // Optional: scope to specific location (null = all)
  status               StocktakeStatus  @default(DRAFT)
  blindCount           Boolean          @default(true) // Hide expected qty from counters
  varianceThresholdPct Decimal?         @db.Decimal(5, 2) // e.g., 5.00 = 5%
  varianceThresholdAbs Decimal?         @db.Decimal(12, 4) // Absolute qty threshold
  // Workflow timestamps + actors
  createdById          String
  startedById          String?
  startedAt            DateTime?
  submittedById        String?
  submittedAt          DateTime?
  approvedById         String?
  approvedAt           DateTime?
  postedById           String?
  postedAt             DateTime?
  voidedById           String?
  voidedAt             DateTime?
  voidReason           String?
  // Summary stats (computed on finalization)
  totalLines           Int              @default(0)
  linesWithVariance    Int              @default(0)
  totalVarianceValue   Decimal?         @db.Decimal(12, 2) // Variance in currency
  // M11.13: GL Posting
  glJournalEntryId     String?
  glPostingStatus      GlPostingStatus?
  glPostingError       String?
  // Metadata + timestamps
  metadata             Json?
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt

  // Relations
  branch         Branch             @relation("StocktakeSessionBranch", fields: [branchId], references: [id], onDelete: Cascade)
  location       InventoryLocation? @relation("StocktakeSessionLocation", fields: [locationId], references: [id], onDelete: SetNull)
  createdBy      User               @relation("StocktakeSessionCreator", fields: [createdById], references: [id], onDelete: Restrict)
  startedBy      User?              @relation("StocktakeSessionStarter", fields: [startedById], references: [id], onDelete: SetNull)
  submittedBy    User?              @relation("StocktakeSessionSubmitter", fields: [submittedById], references: [id], onDelete: SetNull)
  approvedBy     User?              @relation("StocktakeSessionApprover", fields: [approvedById], references: [id], onDelete: SetNull)
  postedBy       User?              @relation("StocktakeSessionPoster", fields: [postedById], references: [id], onDelete: SetNull)
  voidedBy       User?              @relation("StocktakeSessionVoider", fields: [voidedById], references: [id], onDelete: SetNull)
  glJournalEntry JournalEntry?      @relation("StocktakeGlJournal", fields: [glJournalEntryId], references: [id], onDelete: SetNull)
  lines          StocktakeLine[]

  @@unique([orgId, sessionNumber])
  @@index([orgId, branchId])
  @@index([status])
  @@index([createdAt])
  @@map("stocktake_sessions")
}

// Stocktake Line - individual count entries with snapshot
model StocktakeLine {
  id              String    @id @default(cuid())
  sessionId       String
  itemId          String
  locationId      String
  snapshotQty     Decimal   @db.Decimal(12, 4) // Frozen on-hand at session start
  countedQty      Decimal?  @db.Decimal(12, 4) // Counted quantity (null = not counted yet)
  variance        Decimal?  @db.Decimal(12, 4) // countedQty - snapshotQty (computed)
  varianceValue   Decimal?  @db.Decimal(12, 2) // Variance in currency (qty * cost)
  notes           String?
  countedById     String?
  countedAt       DateTime?
  ledgerEntryId   String?   @unique // FK to ledger entry when posted
  reversalEntryId String?   @unique // FK to reversal entry when voided
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  session       StocktakeSession      @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  item          InventoryItem         @relation("StocktakeLineItem", fields: [itemId], references: [id], onDelete: Restrict)
  location      InventoryLocation     @relation("StocktakeLineLocation", fields: [locationId], references: [id], onDelete: Restrict)
  countedBy     User?                 @relation("StocktakeLineCounter", fields: [countedById], references: [id], onDelete: SetNull)
  ledgerEntry   InventoryLedgerEntry? @relation("StocktakeLedgerEntry", fields: [ledgerEntryId], references: [id], onDelete: SetNull)
  reversalEntry InventoryLedgerEntry? @relation("StocktakeReversalEntry", fields: [reversalEntryId], references: [id], onDelete: SetNull)

  @@unique([sessionId, itemId, locationId])
  @@index([sessionId])
  @@index([itemId])
  @@map("stocktake_lines")
}

// ============================================
// M11.2 Purchasing & Receiving Core
// ============================================

enum PurchaseOrderStatus {
  DRAFT
  SUBMITTED
  APPROVED
  PARTIALLY_RECEIVED
  RECEIVED
  CANCELLED
}

enum GoodsReceiptStatus {
  DRAFT
  POSTED
  VOID
}

// Enterprise Purchase Order with Vendor from accounting
model PurchaseOrderV2 {
  id                String              @id @default(cuid())
  orgId             String
  branchId          String
  vendorId          String // FK to Vendor (accounting)
  poNumber          String // Auto-generated or user-provided
  status            PurchaseOrderStatus @default(DRAFT)
  expectedAt        DateTime? // Expected delivery date
  notes             String?
  totalAmount       Decimal             @default(0) @db.Decimal(12, 2)
  createdById       String
  approvedById      String?
  approvedAt        DateTime?
  idempotencyKey    String? // For integration-based creation
  reorderRunId      String? // M11.6: Reference to reorder run that generated this PO
  optimizationRunId String? // M11.14: Reference to forecast optimization run
  metadata          Json?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  branch          Branch                   @relation("BranchPurchaseOrdersV2", fields: [branchId], references: [id], onDelete: Cascade)
  vendor          Vendor                   @relation("VendorPurchaseOrders", fields: [vendorId], references: [id], onDelete: Restrict)
  createdBy       User                     @relation("POCreator", fields: [createdById], references: [id], onDelete: Restrict)
  approvedBy      User?                    @relation("POApprover", fields: [approvedById], references: [id], onDelete: SetNull)
  reorderRun      ReorderSuggestionRun?    @relation("ReorderRunPOs", fields: [reorderRunId], references: [id], onDelete: SetNull)
  optimizationRun ForecastOptimizationRun? @relation("OptimizationRunPOs", fields: [optimizationRunId], references: [id], onDelete: SetNull)
  lines           PurchaseOrderLineV2[]
  receipts        GoodsReceiptV2[]

  @@unique([orgId, poNumber])
  @@unique([orgId, idempotencyKey])
  @@index([orgId, branchId])
  @@index([vendorId])
  @@index([status])
  @@index([reorderRunId])
  @@index([optimizationRunId])
  @@map("purchase_orders_v2")
}

// Purchase Order Line with UOM conversion and over-receipt policy
model PurchaseOrderLineV2 {
  id               String   @id @default(cuid())
  purchaseOrderId  String
  itemId           String
  qtyOrderedInput  Decimal  @db.Decimal(12, 4) // Quantity in input UOM
  inputUomId       String // UOM of input quantity
  qtyOrderedBase   Decimal  @db.Decimal(12, 4) // Converted to item's base UOM
  unitCost         Decimal  @db.Decimal(12, 4) // Cost per unit (in org currency)
  qtyReceivedBase  Decimal  @default(0) @db.Decimal(12, 4) // Total received in base UOM
  allowOverReceipt Boolean  @default(false) // Policy: allow receiving more than ordered
  notes            String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  purchaseOrder PurchaseOrderV2      @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  item          InventoryItem        @relation("POLineItem", fields: [itemId], references: [id], onDelete: Restrict)
  inputUom      UnitOfMeasure        @relation("POLineInputUom", fields: [inputUomId], references: [id], onDelete: Restrict)
  receiptLines  GoodsReceiptLineV2[]

  @@index([purchaseOrderId])
  @@index([itemId])
  @@map("purchase_order_lines_v2")
}

// Goods Receipt with idempotent posting
model GoodsReceiptV2 {
  id               String             @id @default(cuid())
  orgId            String
  branchId         String
  purchaseOrderId  String
  receiptNumber    String // Auto-generated
  status           GoodsReceiptStatus @default(DRAFT)
  receivedAt       DateTime           @default(now())
  postedAt         DateTime?
  postedById       String?
  idempotencyKey   String? // UNIQUE per org - prevents double posting
  referenceNumber  String? // External reference (e.g., delivery note)
  notes            String?
  metadata         Json?
  // M11.13: GL Posting
  glJournalEntryId String?
  glPostingStatus  GlPostingStatus?
  glPostingError   String?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt

  branch         Branch               @relation("BranchGoodsReceiptsV2", fields: [branchId], references: [id], onDelete: Cascade)
  purchaseOrder  PurchaseOrderV2      @relation(fields: [purchaseOrderId], references: [id], onDelete: Restrict)
  postedBy       User?                @relation("ReceiptPostedBy", fields: [postedById], references: [id], onDelete: SetNull)
  glJournalEntry JournalEntry?        @relation("GoodsReceiptGlJournal", fields: [glJournalEntryId], references: [id], onDelete: SetNull)
  lines          GoodsReceiptLineV2[]

  @@unique([orgId, receiptNumber])
  @@unique([orgId, idempotencyKey])
  @@index([orgId, branchId])
  @@index([purchaseOrderId])
  @@index([status])
  @@map("goods_receipts_v2")
}

// Goods Receipt Line with ledger posting
model GoodsReceiptLineV2 {
  id               String   @id @default(cuid())
  goodsReceiptId   String
  itemId           String
  locationId       String // Receiving location
  poLineId         String? // Link to PO line
  qtyReceivedInput Decimal  @db.Decimal(12, 4) // Quantity in input UOM
  inputUomId       String // UOM of input quantity
  qtyReceivedBase  Decimal  @db.Decimal(12, 4) // Converted to item's base UOM
  unitCost         Decimal  @db.Decimal(12, 4) // Cost per unit (may override PO line)
  notes            String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // M78: Soft delete for audit compliance
  deletedAt    DateTime?
  deletedBy    String?
  deleteReason String?

  goodsReceipt GoodsReceiptV2       @relation(fields: [goodsReceiptId], references: [id], onDelete: Cascade)
  item         InventoryItem        @relation("ReceiptLineItem", fields: [itemId], references: [id], onDelete: Restrict)
  location     InventoryLocation    @relation("ReceiptLineLocation", fields: [locationId], references: [id], onDelete: Restrict)
  poLine       PurchaseOrderLineV2? @relation(fields: [poLineId], references: [id], onDelete: SetNull)
  inputUom     UnitOfMeasure        @relation("ReceiptLineInputUom", fields: [inputUomId], references: [id], onDelete: Restrict)

  @@index([goodsReceiptId])
  @@index([itemId])
  @@index([poLineId])
  @@index([deletedAt]) // M78: Fast filtering
  @@map("goods_receipt_lines_v2")
}

// ===== M11.3: Inventory Transfers + Waste =====

enum InventoryTransferStatus {
  DRAFT
  IN_TRANSIT
  RECEIVED
  VOID
}

enum InventoryWasteStatus {
  DRAFT
  POSTED
  VOID
}

// M11.13: GL Posting Status for inventory documents
enum GlPostingStatus {
  PENDING
  POSTED
  FAILED
  SKIPPED
}

enum InventoryWasteReason {
  DAMAGED
  EXPIRED
  THEFT
  SPOILED
  SAMPLE
  OTHER
}

// Transfer document for inter-branch or intra-branch stock movements
model InventoryTransfer {
  id             String                  @id @default(cuid())
  orgId          String
  fromBranchId   String
  toBranchId     String
  transferNumber String // Auto-generated (TRF-YYMM-XXXXX)
  status         InventoryTransferStatus @default(DRAFT)
  shippedAt      DateTime?
  shippedById    String?
  receivedAt     DateTime?
  receivedById   String?
  notes          String?
  idempotencyKey String? // Unique per org - prevents duplicate creation
  metadata       Json?
  createdById    String
  createdAt      DateTime                @default(now())
  updatedAt      DateTime                @updatedAt

  fromBranch Branch                  @relation("TransferFromBranch", fields: [fromBranchId], references: [id], onDelete: Restrict)
  toBranch   Branch                  @relation("TransferToBranch", fields: [toBranchId], references: [id], onDelete: Restrict)
  createdBy  User                    @relation("TransferCreator", fields: [createdById], references: [id], onDelete: Restrict)
  shippedBy  User?                   @relation("TransferShipper", fields: [shippedById], references: [id], onDelete: SetNull)
  receivedBy User?                   @relation("TransferReceiver", fields: [receivedById], references: [id], onDelete: SetNull)
  lines      InventoryTransferLine[]

  @@unique([orgId, transferNumber])
  @@unique([orgId, idempotencyKey])
  @@index([orgId, fromBranchId])
  @@index([orgId, toBranchId])
  @@index([status])
  @@map("inventory_transfers")
}

// Transfer line items
model InventoryTransferLine {
  id             String   @id @default(cuid())
  transferId     String
  itemId         String
  fromLocationId String // Source location (in fromBranch)
  toLocationId   String // Destination location (in toBranch)
  lotId          String? // M11.7: Optional lot reference for lot-aware transfers
  qtyShipped     Decimal  @db.Decimal(12, 4)
  qtyReceived    Decimal  @default(0) @db.Decimal(12, 4)
  notes          String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  transfer     InventoryTransfer @relation(fields: [transferId], references: [id], onDelete: Cascade)
  item         InventoryItem     @relation("TransferLineItem", fields: [itemId], references: [id], onDelete: Restrict)
  fromLocation InventoryLocation @relation("TransferLineFromLocation", fields: [fromLocationId], references: [id], onDelete: Restrict)
  toLocation   InventoryLocation @relation("TransferLineToLocation", fields: [toLocationId], references: [id], onDelete: Restrict)
  lot          InventoryLot?     @relation("TransferLineLot", fields: [lotId], references: [id], onDelete: SetNull)

  @@index([transferId])
  @@index([itemId])
  @@index([lotId])
  @@map("inventory_transfer_lines")
}

// Waste document for recording stock losses
model InventoryWaste {
  id               String               @id @default(cuid())
  orgId            String
  branchId         String
  wasteNumber      String // Auto-generated (WST-YYMM-XXXXX)
  status           InventoryWasteStatus @default(DRAFT)
  reason           InventoryWasteReason @default(OTHER)
  postedAt         DateTime?
  postedById       String?
  notes            String?
  idempotencyKey   String? // Unique per org - prevents duplicate creation
  metadata         Json?
  createdById      String
  // M11.13: GL Posting
  glJournalEntryId String?
  glPostingStatus  GlPostingStatus?
  glPostingError   String?
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt

  branch         Branch               @relation("WasteBranch", fields: [branchId], references: [id], onDelete: Cascade)
  createdBy      User                 @relation("WasteCreator", fields: [createdById], references: [id], onDelete: Restrict)
  postedBy       User?                @relation("WastePoster", fields: [postedById], references: [id], onDelete: SetNull)
  glJournalEntry JournalEntry?        @relation("WasteGlJournal", fields: [glJournalEntryId], references: [id], onDelete: SetNull)
  lines          InventoryWasteLine[]

  @@unique([orgId, wasteNumber])
  @@unique([orgId, idempotencyKey])
  @@index([orgId, branchId])
  @@index([status])
  @@map("inventory_waste")
}

// Waste line items
model InventoryWasteLine {
  id         String                @id @default(cuid())
  wasteId    String
  itemId     String
  locationId String
  lotId      String? // M11.7: Optional lot reference for lot-aware waste
  qty        Decimal               @db.Decimal(12, 4) // Quantity wasted (positive)
  unitCost   Decimal?              @db.Decimal(12, 4) // Optional cost tracking
  reason     InventoryWasteReason? // Line-level override
  notes      String?
  createdAt  DateTime              @default(now())
  updatedAt  DateTime              @updatedAt

  waste    InventoryWaste    @relation(fields: [wasteId], references: [id], onDelete: Cascade)
  item     InventoryItem     @relation("WasteLineItem", fields: [itemId], references: [id], onDelete: Restrict)
  location InventoryLocation @relation("WasteLineLocation", fields: [locationId], references: [id], onDelete: Restrict)
  lot      InventoryLot?     @relation("WasteLineLot", fields: [lotId], references: [id], onDelete: SetNull)

  @@index([wasteId])
  @@index([itemId])
  @@index([lotId])
  @@map("inventory_waste_lines")
}

// ========================================
// M11.4: Recipes/BOM + POS Depletion
// ========================================

enum RecipeTargetType {
  MENU_ITEM
  INVENTORY_ITEM
}

enum DepletionStatus {
  PENDING
  POSTED
  FAILED
  SKIPPED
}

// Recipe Header - links sellable items to ingredient lists
model Recipe {
  id            String           @id @default(cuid())
  orgId         String
  name          String
  targetType    RecipeTargetType // MENU_ITEM or INVENTORY_ITEM
  targetId      String // menuItemId or inventoryItemId
  outputQtyBase Decimal          @default(1) @db.Decimal(12, 4)
  outputUomId   String? // Optional: for advanced yield tracking
  isActive      Boolean          @default(true)
  createdById   String
  updatedById   String?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  // Relations
  org               Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)
  lines             RecipeLine[]
  createdBy         User              @relation("RecipeCreator", fields: [createdById], references: [id], onDelete: Restrict)
  updatedBy         User?             @relation("RecipeUpdater", fields: [updatedById], references: [id], onDelete: SetNull)
  outputUom         UnitOfMeasure?    @relation("RecipeOutputUom", fields: [outputUomId], references: [id], onDelete: SetNull)
  // M11.9: Production Batches
  productionBatches ProductionBatch[] @relation("ProductionBatchRecipe")

  @@unique([orgId, targetType, targetId])
  @@index([orgId])
  @@index([targetType, targetId])
  @@map("recipes")
}

// Recipe Line - ingredient with quantity in input UOM + pre-computed base qty
model RecipeLine {
  id              String   @id @default(cuid())
  recipeId        String
  inventoryItemId String
  qtyInput        Decimal  @db.Decimal(12, 4) // Quantity in input UOM
  inputUomId      String
  qtyBase         Decimal  @db.Decimal(12, 4) // Pre-computed in item's base UOM
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  recipe        Recipe        @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  inventoryItem InventoryItem @relation("RecipeLineItem", fields: [inventoryItemId], references: [id], onDelete: Restrict)
  inputUom      UnitOfMeasure @relation("RecipeLineInputUom", fields: [inputUomId], references: [id], onDelete: Restrict)

  @@index([recipeId])
  @@index([inventoryItemId])
  @@map("recipe_lines")
}

// Order Inventory Depletion - idempotency record for POS depletion
model OrderInventoryDepletion {
  id               String           @id @default(cuid())
  orgId            String
  orderId          String           @unique
  branchId         String
  locationId       String
  status           DepletionStatus  @default(PENDING)
  errorCode        String?
  errorMessage     String?
  ledgerEntryCount Int              @default(0)
  metadata         Json? // Store details like itemsProcessed, itemsSkipped, etc.
  // M11.13: GL Posting
  glJournalEntryId String?
  glPostingStatus  GlPostingStatus?
  glPostingError   String?
  createdAt        DateTime         @default(now())
  postedAt         DateTime?

  // M78: Soft delete for audit compliance
  deletedAt    DateTime?
  deletedBy    String?
  deleteReason String?

  // Relations
  order          Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  branch         Branch            @relation("DepletionBranch", fields: [branchId], references: [id], onDelete: Cascade)
  location       InventoryLocation @relation("DepletionLocation", fields: [locationId], references: [id], onDelete: Restrict)
  glJournalEntry JournalEntry?     @relation("DepletionGlJournal", fields: [glJournalEntryId], references: [id], onDelete: SetNull)

  // M11.5: COGS breakdown
  costBreakdowns DepletionCostBreakdown[]

  @@unique([orgId, orderId])
  @@index([orderId])
  @@index([branchId, status])
  @@index([deletedAt]) // M78: Fast filtering
  @@map("order_inventory_depletions")
}

// ===== M11.5: Inventory Costing + Valuation + COGS =====

enum CostMethod {
  WAC // Weighted Average Cost
}

enum CostSourceType {
  GOODS_RECEIPT
  MANUAL_ADJUSTMENT
  INITIAL_SEED
  PRODUCTION // M11.9: Production batch output
}

// Append-only cost layer - records cost history for audit trail
model InventoryCostLayer {
  id          String         @id @default(cuid())
  orgId       String
  branchId    String
  itemId      String
  locationId  String? // Optional: for location-level costing
  method      CostMethod     @default(WAC)
  qtyReceived Decimal        @db.Decimal(12, 4) // Qty added in this layer
  unitCost    Decimal        @db.Decimal(12, 4) // Cost per unit in base UOM
  priorWac    Decimal        @db.Decimal(12, 4) // WAC before this layer
  newWac      Decimal        @db.Decimal(12, 4) // WAC after this layer
  sourceType  CostSourceType // GOODS_RECEIPT, MANUAL_ADJUSTMENT, INITIAL_SEED
  sourceId    String // Receipt line ID, adjustment ID, etc.
  effectiveAt DateTime       @default(now())
  createdById String
  metadata    Json?
  createdAt   DateTime       @default(now())

  // Relations
  org       Org                @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch    Branch             @relation("CostLayerBranch", fields: [branchId], references: [id], onDelete: Cascade)
  item      InventoryItem      @relation("CostLayerItem", fields: [itemId], references: [id], onDelete: Restrict)
  location  InventoryLocation? @relation("CostLayerLocation", fields: [locationId], references: [id], onDelete: SetNull)
  createdBy User               @relation("CostLayerCreator", fields: [createdById], references: [id], onDelete: Restrict)

  @@index([orgId, branchId, itemId])
  @@index([itemId, effectiveAt])
  @@index([sourceType, sourceId])
  @@map("inventory_cost_layers")
}

// Depletion Cost Breakdown - COGS per depleted item
model DepletionCostBreakdown {
  id          String   @id @default(cuid())
  orgId       String
  depletionId String
  orderId     String
  itemId      String
  qtyDepleted Decimal  @db.Decimal(12, 4) // Quantity consumed (positive)
  unitCost    Decimal  @db.Decimal(12, 4) // WAC at time of depletion
  lineCogs    Decimal  @db.Decimal(12, 4) // qtyDepleted Ã— unitCost
  computedAt  DateTime @default(now())
  metadata    Json?
  createdAt   DateTime @default(now())

  // M78: Soft delete for audit compliance (SOX, IFRS, tax audit trails)
  deletedAt    DateTime?
  deletedBy    String? // User ID who soft-deleted this record
  deleteReason String? // CORRECTION, PERIOD_CLOSE, AUDIT_ADJUSTMENT

  // Relations
  depletion OrderInventoryDepletion @relation(fields: [depletionId], references: [id], onDelete: Cascade)
  item      InventoryItem           @relation("DepletionCostItem", fields: [itemId], references: [id], onDelete: Restrict)

  @@unique([depletionId, itemId])
  @@index([orgId, orderId])
  @@index([itemId])
  @@index([deletedAt]) // M78: Fast filtering of active/deleted records
  @@map("depletion_cost_breakdowns")
}

// ============================================================================
// M80: Prep Items Module Phase 1
// ============================================================================

// PrepItem - Semi-finished goods produced from raw ingredients
// Used in recipes as intermediate components (e.g., tomato sauce, burger patties, pizza dough)
model PrepItem {
  id                      String   @id @default(cuid())
  orgId                   String
  branchId                String
  name                    String
  yieldQty                Decimal  @db.Decimal(12, 4) // Output quantity from one batch
  yieldUomId              String // FK to UnitOfMeasure (output unit, e.g., "liter", "kg", "each")
  prepMinutes             Int      @default(0) // Average prep time per batch
  notes                   String?  @db.Text
  isActive                Boolean  @default(true)
  createdById             String
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt
  outputInventoryItemId   String?  @map("output_inventory_item_id") // M80: Links prep output to inventory for recipe usage

  // Relations
  org            Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch         Branch            @relation(fields: [branchId], references: [id], onDelete: Cascade)
  yieldUom       UnitOfMeasure     @relation("PrepItemYieldUom", fields: [yieldUomId], references: [id], onDelete: Restrict)
  createdBy      User              @relation(fields: [createdById], references: [id], onDelete: Restrict)
  outputItem     InventoryItem?    @relation("PrepItemOutput", fields: [outputInventoryItemId], references: [id], onDelete: SetNull)
  lines          PrepLine[]

  @@index([orgId, branchId])
  @@index([orgId, name])
  @@map("prep_items")
}

// PrepLine - Ingredients required to make a PrepItem
model PrepLine {
  id                String   @id @default(cuid())
  prepItemId        String
  inventoryItemId   String
  qty               Decimal  @db.Decimal(12, 4) // Quantity of ingredient needed
  uomId             String // FK to UnitOfMeasure
  notes             String?
  createdAt         DateTime @default(now())

  // Relations
  prepItem      PrepItem      @relation(fields: [prepItemId], references: [id], onDelete: Cascade)
  inventoryItem InventoryItem @relation("PrepLineItem", fields: [inventoryItemId], references: [id], onDelete: Restrict)
  uom           UnitOfMeasure @relation("PrepLineUom", fields: [uomId], references: [id], onDelete: Restrict)

  @@index([prepItemId])
  @@index([inventoryItemId])
  @@map("prep_lines")
}

// ============================================================================
// M11.6: Supplier Catalog + Price Lists + Reorder Automation
// ============================================================================

// Supplier Item - Maps vendor items to inventory items
model SupplierItem {
  id                        String   @id @default(cuid())
  orgId                     String
  vendorId                  String // FK to Vendor (accounting)
  inventoryItemId           String // FK to InventoryItem
  vendorSku                 String // Vendor's SKU/part number
  vendorUomId               String? // FK to UnitOfMeasure (ordering unit, e.g., "case")
  uomConversionFactorToBase Decimal  @default(1) @db.Decimal(12, 6) // vendorQty Ã— factor = baseQty
  packSizeLabel             String? // Human-readable, e.g., "12x500ml"
  leadTimeDays              Int      @default(0)
  minOrderQtyVendorUom      Decimal  @default(0) @db.Decimal(12, 4)
  isPreferred               Boolean  @default(false)
  isActive                  Boolean  @default(true)
  metadata                  Json?
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  // Relations
  vendor        Vendor          @relation("VendorSupplierItems", fields: [vendorId], references: [id], onDelete: Restrict)
  inventoryItem InventoryItem   @relation("ItemSupplierItems", fields: [inventoryItemId], references: [id], onDelete: Restrict)
  vendorUom     UnitOfMeasure?  @relation("SupplierItemVendorUom", fields: [vendorUomId], references: [id], onDelete: SetNull)
  prices        SupplierPrice[]

  @@unique([orgId, vendorId, inventoryItemId])
  @@unique([orgId, vendorId, vendorSku])
  @@index([orgId])
  @@index([vendorId])
  @@index([inventoryItemId])
  @@map("supplier_items")
}

// Supplier Price - Price history for supplier items
enum SupplierPriceSource {
  MANUAL
  RECEIPT_DERIVED
}

model SupplierPrice {
  id                  String              @id @default(cuid())
  orgId               String
  supplierItemId      String // FK to SupplierItem
  currency            String              @default("USD")
  unitPriceVendorUom  Decimal             @db.Decimal(12, 4) // Price per vendor UOM
  effectiveFrom       DateTime
  effectiveTo         DateTime? // null = currently active
  source              SupplierPriceSource @default(MANUAL)
  sourceReceiptLineId String? // For RECEIPT_DERIVED idempotency
  note                String?
  createdAt           DateTime            @default(now())

  // Relations
  supplierItem SupplierItem @relation(fields: [supplierItemId], references: [id], onDelete: Cascade)

  @@unique([supplierItemId, sourceReceiptLineId]) // Idempotency for receipt-derived
  @@index([supplierItemId])
  @@index([orgId])
  @@map("supplier_prices")
}

// Reorder Policy - Branch-scoped override for reorder points
model ReorderPolicy {
  id                       String   @id @default(cuid())
  orgId                    String
  branchId                 String
  inventoryItemId          String
  reorderPointBaseQty      Decimal  @db.Decimal(12, 4)
  reorderQtyBaseQty        Decimal  @db.Decimal(12, 4)
  preferredLocationId      String?
  preferredVendorId        String?
  isActive                 Boolean  @default(true)
  // M11.14: Forecasting + Optimization fields
  leadTimeDays             Int      @default(3)
  safetyStockDays          Int      @default(2)
  minOrderQty              Decimal? @db.Decimal(12, 4)
  includeInTransit         Boolean  @default(true)
  includeOpenPOs           Boolean  @default(true)
  includeQuarantinedLots   Boolean  @default(false)
  includeRecallBlockedLots Boolean  @default(false)
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt

  // Relations
  branch          Branch        @relation("BranchReorderPolicies", fields: [branchId], references: [id], onDelete: Cascade)
  inventoryItem   InventoryItem @relation("ItemReorderPolicies", fields: [inventoryItemId], references: [id], onDelete: Restrict)
  preferredVendor Vendor?       @relation("PolicyPreferredVendor", fields: [preferredVendorId], references: [id], onDelete: SetNull)

  @@unique([orgId, branchId, inventoryItemId])
  @@index([orgId, branchId])
  @@map("reorder_policies")
}

// Reorder Suggestion Run - Batch of suggestions
model ReorderSuggestionRun {
  id                String   @id @default(cuid())
  orgId             String
  branchId          String
  asOf              DateTime @default(now())
  deterministicHash String // SHA256 of sorted inputs for idempotency
  createdById       String
  createdAt         DateTime @default(now())

  // Relations
  branch       Branch                  @relation("BranchReorderRuns", fields: [branchId], references: [id], onDelete: Cascade)
  createdBy    User                    @relation("ReorderRunCreator", fields: [createdById], references: [id], onDelete: Restrict)
  lines        ReorderSuggestionLine[]
  generatedPOs PurchaseOrderV2[]       @relation("ReorderRunPOs")

  @@unique([orgId, branchId, deterministicHash])
  @@index([orgId, branchId])
  @@map("reorder_suggestion_runs")
}

// Reorder Reason Code
enum ReorderReasonCode {
  BELOW_REORDER_POINT
  NEGATIVE_ON_HAND
  MANUAL_TRIGGER
}

// Reorder Suggestion Line - Individual item suggestion
model ReorderSuggestionLine {
  id                   String            @id @default(cuid())
  orgId                String
  runId                String
  inventoryItemId      String
  onHandBaseQty        Decimal           @db.Decimal(12, 4)
  reorderPointBaseQty  Decimal           @db.Decimal(12, 4)
  suggestedBaseQty     Decimal           @db.Decimal(12, 4)
  suggestedVendorId    String?
  suggestedVendorUomId String?
  suggestedVendorQty   Decimal?          @db.Decimal(12, 4)
  reasonCode           ReorderReasonCode
  createdAt            DateTime          @default(now())

  // Relations
  run             ReorderSuggestionRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  inventoryItem   InventoryItem        @relation("ItemReorderSuggestions", fields: [inventoryItemId], references: [id], onDelete: Restrict)
  suggestedVendor Vendor?              @relation("SuggestionVendor", fields: [suggestedVendorId], references: [id], onDelete: SetNull)

  @@unique([runId, inventoryItemId])
  @@index([runId])
  @@map("reorder_suggestion_lines")
}

// ============================================================================
// M11.14: Demand Forecasting + Reorder Optimization
// ============================================================================

// Forecast model type
enum ForecastModelType {
  TRAILING_MOVING_AVG // Simple moving average
  EXPONENTIAL_SMOOTH // Simple exponential smoothing
}

// Forecast optimization run status
enum ForecastOptimizationStatus {
  DRAFT // Created but not finalized
  GENERATED // Optimization complete
  PO_CREATED // Draft PO(s) created from this run
}

// Forecast reason codes
enum ForecastReasonCode {
  BELOW_REORDER_POINT // Current on-hand < reorder point
  FORECAST_DRIVEN // Forecast demand exceeds available
  STOCKOUT_RISK // Available < (lead time * avg daily)
  LEAD_TIME_BUFFER // Adding safety stock buffer
}

// Demand Forecast Snapshot - Point-in-time forecast for an item at a branch
model DemandForecastSnapshot {
  id                String            @id @default(cuid())
  orgId             String
  branchId          String
  inventoryItemId   String
  windowDays        Int               @default(14) // Lookback window
  horizonDays       Int               @default(14) // Forward projection
  model             ForecastModelType @default(TRAILING_MOVING_AVG)
  modelVersion      String            @default("1.0.0")
  // Aggregate outputs
  avgDailyQty       Decimal           @db.Decimal(12, 4)
  forecastTotalQty  Decimal           @db.Decimal(12, 4)
  confidenceLow     Decimal           @db.Decimal(12, 4)
  confidenceHigh    Decimal           @db.Decimal(12, 4)
  lastObservedDate  DateTime?
  dataPoints        Int               @default(0) // Number of days with data
  // Idempotency
  deterministicHash String            @unique
  // Metadata
  generatedById     String?
  generatedAt       DateTime          @default(now())
  createdAt         DateTime          @default(now())

  // Daily breakdown (JSON for simplicity - stable ordering ensured)
  dailyForecast Json? // Array of {date, qty, low, high}

  // Relations
  branch        Branch        @relation("BranchForecastSnapshots", fields: [branchId], references: [id], onDelete: Cascade)
  inventoryItem InventoryItem @relation("ItemForecastSnapshots", fields: [inventoryItemId], references: [id], onDelete: Restrict)
  generatedBy   User?         @relation("ForecastSnapshotCreator", fields: [generatedById], references: [id], onDelete: SetNull)

  // Linked optimization runs
  optimizationRuns ForecastOptimizationRun[] @relation("OptimizationForecastSnapshot")

  @@index([orgId, branchId])
  @@index([orgId, branchId, inventoryItemId])
  @@index([generatedAt])
  @@map("demand_forecast_snapshots")
}

// Forecast Optimization Run - Batch of optimized reorder suggestions
model ForecastOptimizationRun {
  id                      String                     @id @default(cuid())
  orgId                   String
  branchId                String
  horizonDays             Int                        @default(14)
  leadTimeDaysOverride    Int? // Override policy default
  safetyStockDaysOverride Int? // Override policy default
  status                  ForecastOptimizationStatus @default(GENERATED)
  // Linked forecast snapshot (primary reference)
  usedSnapshotId          String?
  // Idempotency
  deterministicHash       String
  // Totals
  itemCount               Int                        @default(0)
  totalSuggestedQty       Decimal                    @default(0) @db.Decimal(12, 4)
  // Metadata
  createdById             String
  createdAt               DateTime                   @default(now())

  // Relations
  branch       Branch                     @relation("BranchOptimizationRuns", fields: [branchId], references: [id], onDelete: Cascade)
  createdBy    User                       @relation("OptimizationRunCreator", fields: [createdById], references: [id], onDelete: Restrict)
  usedSnapshot DemandForecastSnapshot?    @relation("OptimizationForecastSnapshot", fields: [usedSnapshotId], references: [id], onDelete: SetNull)
  lines        ForecastOptimizationLine[]
  generatedPOs PurchaseOrderV2[]          @relation("OptimizationRunPOs")

  @@unique([orgId, branchId, deterministicHash])
  @@index([orgId, branchId])
  @@index([createdAt])
  @@map("forecast_optimization_runs")
}

// Forecast Optimization Line - Per-item suggestion with breakdown
model ForecastOptimizationLine {
  id                String               @id @default(cuid())
  orgId             String
  runId             String
  inventoryItemId   String
  // Current state
  onHandQty         Decimal              @db.Decimal(12, 4)
  inTransitQty      Decimal              @default(0) @db.Decimal(12, 4)
  onOrderQty        Decimal              @default(0) @db.Decimal(12, 4)
  quarantinedQty    Decimal              @default(0) @db.Decimal(12, 4)
  availableQty      Decimal              @db.Decimal(12, 4)
  // Forecast inputs
  avgDailyQty       Decimal              @db.Decimal(12, 4)
  forecastDemandQty Decimal              @db.Decimal(12, 4)
  // Optimization outputs
  targetStockQty    Decimal              @db.Decimal(12, 4)
  reorderPointQty   Decimal              @db.Decimal(12, 4)
  suggestedQty      Decimal              @db.Decimal(12, 4)
  // Explainability
  reasonCodes       ForecastReasonCode[]
  explanation       String
  // Vendor suggestion (from policy)
  suggestedVendorId String?
  createdAt         DateTime             @default(now())

  // Relations
  run             ForecastOptimizationRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  inventoryItem   InventoryItem           @relation("ItemOptimizationLines", fields: [inventoryItemId], references: [id], onDelete: Restrict)
  suggestedVendor Vendor?                 @relation("OptimizationLineVendor", fields: [suggestedVendorId], references: [id], onDelete: SetNull)

  @@unique([runId, inventoryItemId])
  @@index([runId])
  @@map("forecast_optimization_lines")
}

// ============================================================================
// M11.7: Lot/Batch + Expiry + Traceability (FEFO Allocation)
// ============================================================================

enum LotStatus {
  ACTIVE // Available for allocation
  QUARANTINE // Held for inspection, not allocable
  EXPIRED // Past expiry date, auto-set by system
  DEPLETED // remainingQty = 0
}

// Inventory Lot - Tracks individual lots/batches per item+branch+location
model InventoryLot {
  id                String    @id @default(cuid())
  orgId             String
  branchId          String
  itemId            String
  locationId        String
  lotNumber         String // User-visible lot/batch number
  receivedQty       Decimal   @db.Decimal(12, 4) // Original received qty
  remainingQty      Decimal   @db.Decimal(12, 4) // Current qty available
  unitCost          Decimal?  @db.Decimal(12, 4) // Cost at time of receipt
  expiryDate        DateTime? // Optional expiry date
  status            LotStatus @default(ACTIVE)
  manufacturingDate DateTime? // Optional manufacturing date
  supplierLotRef    String? // Supplier's lot reference (for traceability)
  sourceType        String // GOODS_RECEIPT, TRANSFER_IN, ADJUSTMENT
  sourceId          String? // ID of source record
  notes             String?
  metadata          Json?
  createdById       String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  org       Org               @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch    Branch            @relation("LotBranch", fields: [branchId], references: [id], onDelete: Cascade)
  item      InventoryItem     @relation("LotItem", fields: [itemId], references: [id], onDelete: Restrict)
  location  InventoryLocation @relation("LotLocation", fields: [locationId], references: [id], onDelete: Restrict)
  createdBy User?             @relation("LotCreator", fields: [createdById], references: [id], onDelete: SetNull)

  // Allocation tracking
  allocations LotLedgerAllocation[]

  // Transfer/Waste line relations
  transferLinesFrom InventoryTransferLine[] @relation("TransferLineLot")
  wasteLines        InventoryWasteLine[]    @relation("WasteLineLot")

  // M11.8: Vendor returns + Recall links
  vendorReturnLines    VendorReturnLine[]    @relation("VendorReturnLineLot")
  recallLinks          RecallLotLink[]       @relation("RecallLotLinkLot")
  // M11.9: Production Batch Lines
  productionBatchLines ProductionBatchLine[] @relation("ProductionLineLot")
  // M11.11: Lot Barcodes
  lotBarcodes          InventoryLotBarcode[] @relation("LotBarcodes")

  @@unique([orgId, branchId, itemId, locationId, lotNumber])
  @@index([orgId, branchId, itemId])
  @@index([itemId, locationId])
  @@index([status])
  @@index([expiryDate])
  @@map("inventory_lots")
}

// Lot Ledger Allocation - Links ledger entries to specific lots for traceability
model LotLedgerAllocation {
  id              String   @id @default(cuid())
  orgId           String
  lotId           String
  ledgerEntryId   String? // FK to InventoryLedgerEntry (can be null for waste/transfer pre-ledger)
  allocatedQty    Decimal  @db.Decimal(12, 4) // Quantity allocated from this lot (positive)
  sourceType      String // ORDER, WASTE, TRANSFER_OUT, ADJUSTMENT
  sourceId        String // orderId, wasteId, transferId, etc.
  allocationOrder Int // 1, 2, 3... for FEFO sequence tracking
  metadata        Json?
  createdAt       DateTime @default(now())

  // Relations
  lot         InventoryLot          @relation(fields: [lotId], references: [id], onDelete: Cascade)
  ledgerEntry InventoryLedgerEntry? @relation(fields: [ledgerEntryId], references: [id], onDelete: SetNull)

  @@index([lotId])
  @@index([ledgerEntryId])
  @@index([sourceType, sourceId])
  @@index([orgId, sourceType]) // M11.15: Org-level allocation queries
  @@map("lot_ledger_allocations")
}

// ============================================================================
// M11.8: Vendor Returns + Recall/Quarantine Ops + Expiry Enforcement
// ============================================================================

enum VendorReturnStatus {
  DRAFT // Created, not yet submitted
  SUBMITTED // Awaiting approval
  POSTED // Finalized, ledger entries created
  VOID // Cancelled after post
}

// Vendor Return - Return of inventory items to vendor (RMA)
model VendorReturn {
  id            String             @id @default(cuid())
  orgId         String
  branchId      String
  vendorId      String
  returnNumber  String // Auto-generated return reference
  status        VendorReturnStatus @default(DRAFT)
  notes         String?
  createdById   String
  submittedAt   DateTime?
  submittedById String?
  postedAt      DateTime?
  postedById    String?
  voidedAt      DateTime?
  voidedById    String?
  voidReason    String?
  metadata      Json?
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  // Relations
  org         Org                @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch      Branch             @relation("VendorReturnBranch", fields: [branchId], references: [id], onDelete: Cascade)
  vendor      Vendor             @relation("VendorReturns", fields: [vendorId], references: [id], onDelete: Restrict)
  createdBy   User               @relation("VendorReturnCreator", fields: [createdById], references: [id], onDelete: Restrict)
  submittedBy User?              @relation("VendorReturnSubmitter", fields: [submittedById], references: [id], onDelete: SetNull)
  postedBy    User?              @relation("VendorReturnPoster", fields: [postedById], references: [id], onDelete: SetNull)
  voidedBy    User?              @relation("VendorReturnVoider", fields: [voidedById], references: [id], onDelete: SetNull)
  lines       VendorReturnLine[]

  @@unique([orgId, returnNumber])
  @@index([orgId, branchId])
  @@index([vendorId])
  @@index([status])
  @@index([createdAt])
  @@map("vendor_returns")
}

// Vendor Return Line - Individual items being returned
model VendorReturnLine {
  id               String   @id @default(cuid())
  vendorReturnId   String
  itemId           String
  locationId       String
  requestedBaseQty Decimal  @db.Decimal(12, 4) // Qty requested to return
  postedBaseQty    Decimal? @db.Decimal(12, 4) // Actual qty returned (set on POST)
  uomId            String? // Input UOM (optional, for display)
  lotId            String? // If specified, return from this lot; else FEFO
  unitCost         Decimal? @db.Decimal(12, 4) // For reporting only
  notes            String?
  metadata         Json?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  vendorReturn VendorReturn      @relation(fields: [vendorReturnId], references: [id], onDelete: Cascade)
  item         InventoryItem     @relation("VendorReturnLineItem", fields: [itemId], references: [id], onDelete: Restrict)
  location     InventoryLocation @relation("VendorReturnLineLocation", fields: [locationId], references: [id], onDelete: Restrict)
  uom          UnitOfMeasure?    @relation("VendorReturnLineUOM", fields: [uomId], references: [id], onDelete: SetNull)
  lot          InventoryLot?     @relation("VendorReturnLineLot", fields: [lotId], references: [id], onDelete: SetNull)

  @@index([vendorReturnId])
  @@index([itemId])
  @@index([lotId])
  @@map("vendor_return_lines")
}

enum RecallCaseStatus {
  OPEN // Active recall, blocks allocations
  CLOSED // Resolved, no longer blocks
}

// Recall Case - Enterprise recall management
model RecallCase {
  id          String           @id @default(cuid())
  orgId       String
  branchId    String? // Null = org-wide recall
  caseNumber  String // Auto-generated recall reference
  status      RecallCaseStatus @default(OPEN)
  reason      String // Reason for recall
  notes       String?
  createdById String
  closedAt    DateTime?
  closedById  String?
  closeNotes  String?
  metadata    Json?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Relations
  org       Org             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch    Branch?         @relation("RecallCaseBranch", fields: [branchId], references: [id], onDelete: Cascade)
  createdBy User            @relation("RecallCaseCreator", fields: [createdById], references: [id], onDelete: Restrict)
  closedBy  User?           @relation("RecallCaseCloser", fields: [closedById], references: [id], onDelete: SetNull)
  lotLinks  RecallLotLink[]

  @@unique([orgId, caseNumber])
  @@index([orgId, branchId])
  @@index([status])
  @@index([createdAt])
  @@map("recall_cases")
}

// Recall Lot Link - Links lots to recall cases
model RecallLotLink {
  id           String   @id @default(cuid())
  recallCaseId String
  lotId        String
  linkedAt     DateTime @default(now())
  linkedById   String
  notes        String?

  // Relations
  recallCase RecallCase   @relation(fields: [recallCaseId], references: [id], onDelete: Cascade)
  lot        InventoryLot @relation("RecallLotLinkLot", fields: [lotId], references: [id], onDelete: Cascade)
  linkedBy   User         @relation("RecallLotLinker", fields: [linkedById], references: [id], onDelete: Restrict)

  @@unique([recallCaseId, lotId]) // Each lot can only be linked once per recall
  @@index([lotId])
  @@map("recall_lot_links")
}

// ============================================================================
// M11.9: Production/Manufacturing Batches
// ============================================================================

enum ProductionBatchStatus {
  DRAFT // Created, can edit lines
  POSTED // Finalized, ledger entries created
  VOID // Cancelled after post
}

// Production Batch - Tracks manufacturing/production runs
model ProductionBatch {
  id                   String                @id @default(cuid())
  orgId                String
  branchId             String
  batchNumber          String // Auto-generated reference
  productionLocationId String
  outputItemId         String
  outputQty            Decimal               @db.Decimal(12, 4)
  outputUomId          String
  outputBaseQty        Decimal               @db.Decimal(12, 4)
  outputCost           Decimal?              @db.Decimal(12, 4) // Calculated on POST
  recipeId             String? // Optional recipe reference
  status               ProductionBatchStatus @default(DRAFT)
  producedAt           DateTime?
  producedById         String?
  voidedAt             DateTime?
  voidedById           String?
  voidReason           String?
  notes                String?
  metadata             Json?
  createdById          String
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt

  // Relations
  org                Org                   @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch             Branch                @relation("ProductionBatchBranch", fields: [branchId], references: [id], onDelete: Cascade)
  productionLocation InventoryLocation     @relation("ProductionBatchLocation", fields: [productionLocationId], references: [id], onDelete: Restrict)
  outputItem         InventoryItem         @relation("ProductionBatchOutputItem", fields: [outputItemId], references: [id], onDelete: Restrict)
  outputUom          UnitOfMeasure         @relation("ProductionBatchOutputUom", fields: [outputUomId], references: [id], onDelete: Restrict)
  recipe             Recipe?               @relation("ProductionBatchRecipe", fields: [recipeId], references: [id], onDelete: SetNull)
  producedBy         User?                 @relation("ProductionBatchProducer", fields: [producedById], references: [id], onDelete: SetNull)
  voidedBy           User?                 @relation("ProductionBatchVoider", fields: [voidedById], references: [id], onDelete: SetNull)
  createdBy          User                  @relation("ProductionBatchCreator", fields: [createdById], references: [id], onDelete: Restrict)
  lines              ProductionBatchLine[]

  @@unique([orgId, branchId, batchNumber])
  @@index([orgId, branchId])
  @@index([status])
  @@map("production_batches")
}

// Production Batch Line - Input items consumed in production
model ProductionBatchLine {
  id              String   @id @default(cuid())
  batchId         String
  itemId          String
  locationId      String
  lotId           String? // Specific lot or FEFO allocation
  uomId           String
  qty             Decimal  @db.Decimal(12, 4)
  baseQty         Decimal  @db.Decimal(12, 4)
  consumedBaseQty Decimal? @db.Decimal(12, 4) // Actual consumed on POST
  unitCostAtPost  Decimal? @db.Decimal(12, 4) // WAC captured at POST
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  batch    ProductionBatch   @relation(fields: [batchId], references: [id], onDelete: Cascade)
  item     InventoryItem     @relation("ProductionLineItem", fields: [itemId], references: [id], onDelete: Restrict)
  location InventoryLocation @relation("ProductionLineLocation", fields: [locationId], references: [id], onDelete: Restrict)
  lot      InventoryLot?     @relation("ProductionLineLot", fields: [lotId], references: [id], onDelete: SetNull)
  uom      UnitOfMeasure     @relation("ProductionLineUom", fields: [uomId], references: [id], onDelete: Restrict)

  @@index([batchId])
  @@index([itemId])
  @@index([lotId])
  @@map("production_batch_lines")
}

// ============================================================================
// M11.11: Barcode + Scanner Fast Ops
// ============================================================================

enum BarcodeFormat {
  EAN13
  UPC_A
  CODE128
  QR
  OTHER
}

// Inventory Item Barcode - Multiple barcodes per item, unique per org
model InventoryItemBarcode {
  id          String        @id @default(cuid())
  orgId       String
  itemId      String
  format      BarcodeFormat @default(OTHER)
  value       String // Normalized barcode value
  isPrimary   Boolean       @default(false)
  createdById String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relations
  org       Org           @relation(fields: [orgId], references: [id], onDelete: Cascade)
  item      InventoryItem @relation("ItemBarcodes", fields: [itemId], references: [id], onDelete: Cascade)
  createdBy User?         @relation("BarcodeCreator", fields: [createdById], references: [id], onDelete: SetNull)

  @@unique([orgId, value]) // Barcode value unique within org
  @@index([itemId])
  @@index([value])
  @@map("inventory_item_barcodes")
}

// Inventory Lot Barcode - Direct lot selection for FEFO/traceability workflows
model InventoryLotBarcode {
  id          String        @id @default(cuid())
  orgId       String
  lotId       String
  format      BarcodeFormat @default(OTHER)
  value       String
  createdById String?
  createdAt   DateTime      @default(now())

  // Relations
  org       Org          @relation(fields: [orgId], references: [id], onDelete: Cascade)
  lot       InventoryLot @relation("LotBarcodes", fields: [lotId], references: [id], onDelete: Cascade)
  createdBy User?        @relation("LotBarcodeCreator", fields: [createdById], references: [id], onDelete: SetNull)

  @@unique([orgId, value])
  @@index([lotId])
  @@map("inventory_lot_barcodes")
}

// ============================================================================
// M11.12: Inventory Analytics + Alerts
// ============================================================================

enum InventoryAlertType {
  DEAD_STOCK
  EXPIRY_SOON
  EXPIRED
  BELOW_REORDER_POINT
  HIGH_WASTE
  HIGH_VARIANCE
  PERIOD_CLOSE_BLOCKED      // M12.4: Preclose returned blockers
  PERIOD_CLOSE_APPROVAL_REQ // M12.4: Close request needs L5 action
}

enum InventoryAlertSeverity {
  INFO
  WARN
  CRITICAL
}

enum InventoryAlertStatus {
  OPEN
  ACKNOWLEDGED
  RESOLVED
}

model InventoryAlert {
  id          String                 @id @default(cuid())
  orgId       String
  branchId    String? // Nullable for org-wide alerts
  type        InventoryAlertType
  severity    InventoryAlertSeverity @default(WARN)
  entityType  String // ITEM, LOT, LOCATION, etc.
  entityId    String // ID of the linked entity
  title       String
  detailsJson Json? // Additional details
  status      InventoryAlertStatus   @default(OPEN)

  // Lifecycle tracking
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  acknowledgedAt   DateTime?
  acknowledgedById String?
  resolvedAt       DateTime?
  resolvedById     String?

  // Relations
  org            Org     @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch         Branch? @relation(fields: [branchId], references: [id], onDelete: Cascade)
  acknowledgedBy User?   @relation("AlertAcknowledger", fields: [acknowledgedById], references: [id], onDelete: SetNull)
  resolvedBy     User?   @relation("AlertResolver", fields: [resolvedById], references: [id], onDelete: SetNull)

  // H1: Unique constraint to prevent duplicate OPEN alerts per entity
  @@unique([orgId, branchId, type, entityType, entityId, status])
  @@index([orgId, status])
  @@index([branchId])
  @@index([type])
  @@index([entityType, entityId])
  @@map("inventory_alerts")
}

// ============================================================================
// M12.1: Inventory Period Close + Locking + GL Reconciliation
// ============================================================================

enum InventoryPeriodStatus {
  OPEN
  CLOSED
}

// Inventory Period - Branch-scoped accounting period for inventory
model InventoryPeriod {
  id         String                @id @default(cuid())
  orgId      String
  branchId   String
  startDate  DateTime              @db.Date
  endDate    DateTime              @db.Date // Inclusive (covers entire day)
  status     InventoryPeriodStatus @default(OPEN)
  closedAt   DateTime?
  closedById String?
  lockReason String? // e.g., "Month-end close"
  createdAt  DateTime              @default(now())
  updatedAt  DateTime              @updatedAt

  // Relations
  org      Org    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch   Branch @relation("InventoryPeriodBranch", fields: [branchId], references: [id], onDelete: Cascade)
  closedBy User?  @relation("InventoryPeriodCloser", fields: [closedById], references: [id], onDelete: SetNull)

  valuationSnapshots InventoryValuationSnapshot[]
  movementSummaries  InventoryPeriodMovementSummary[]
  events             InventoryPeriodEvent[]
  closeRequest       InventoryPeriodCloseRequest?   // M12.4: One close request per period

  @@unique([orgId, branchId, startDate, endDate])
  @@index([orgId, branchId])
  @@index([status])
  @@map("inventory_periods")
}

// Valuation Snapshot - Append-only snapshot of inventory value at period close
model InventoryValuationSnapshot {
  id         String   @id @default(cuid())
  orgId      String
  branchId   String
  periodId   String
  itemId     String
  locationId String
  revision   Int      @default(1)  // M12.2: Revision for reopen/re-close
  qtyOnHand  Decimal  @db.Decimal(12, 4)
  wac        Decimal  @db.Decimal(12, 4)
  value      Decimal  @db.Decimal(12, 2)
  asOf       DateTime // Timestamp consistent with endDate boundary
  createdAt  DateTime @default(now())

  // Relations
  period   InventoryPeriod   @relation(fields: [periodId], references: [id], onDelete: Cascade)
  item     InventoryItem     @relation("ValuationSnapshotItem", fields: [itemId], references: [id], onDelete: Restrict)
  location InventoryLocation @relation("ValuationSnapshotLocation", fields: [locationId], references: [id], onDelete: Restrict)

  @@unique([periodId, itemId, locationId, revision])
  @@index([periodId])
  @@index([orgId, branchId])
  @@map("inventory_valuation_snapshots")
}

// Movement Summary - Aggregated movement totals for a period
model InventoryPeriodMovementSummary {
  id        String  @id @default(cuid())
  orgId     String
  branchId  String
  periodId  String
  itemId    String? // null = branch total row
  revision  Int     @default(1)  // M12.2: Revision for reopen/re-close
  // Receive
  receiveQty   Decimal @default(0) @db.Decimal(12, 4)
  receiveValue Decimal @default(0) @db.Decimal(12, 2)
  // Sales/Depletion (COGS)
  depletionQty   Decimal @default(0) @db.Decimal(12, 4)
  depletionValue Decimal @default(0) @db.Decimal(12, 2)
  // Waste
  wasteQty   Decimal @default(0) @db.Decimal(12, 4)
  wasteValue Decimal @default(0) @db.Decimal(12, 2)
  // Transfers
  transferInQty  Decimal @default(0) @db.Decimal(12, 4)
  transferOutQty Decimal @default(0) @db.Decimal(12, 4)
  // Adjustments
  adjustmentQty   Decimal @default(0) @db.Decimal(12, 4)
  adjustmentValue Decimal @default(0) @db.Decimal(12, 2)
  // Count variance (stocktake)
  countVarianceQty   Decimal @default(0) @db.Decimal(12, 4)
  countVarianceValue Decimal @default(0) @db.Decimal(12, 2)
  // Production
  productionConsumeQty   Decimal @default(0) @db.Decimal(12, 4)
  productionConsumeValue Decimal @default(0) @db.Decimal(12, 2)
  productionProduceQty   Decimal @default(0) @db.Decimal(12, 4)
  productionProduceValue Decimal @default(0) @db.Decimal(12, 2)
  createdAt              DateTime @default(now())

  // Relations
  period InventoryPeriod @relation(fields: [periodId], references: [id], onDelete: Cascade)
  item   InventoryItem?  @relation("MovementSummaryItem", fields: [itemId], references: [id], onDelete: Restrict)

  @@unique([periodId, itemId, revision])
  @@index([periodId])
  @@index([orgId, branchId])
  @@map("inventory_period_movement_summaries")
}

// M12.2: Inventory Period Event Types
enum InventoryPeriodEventType {
  CREATED
  CLOSED
  REOPENED
  OVERRIDE_USED
  EXPORT_GENERATED
  // M12.4: Close request workflow events
  CLOSE_REQUEST_CREATED
  CLOSE_REQUEST_SUBMITTED
  CLOSE_REQUEST_APPROVED
  CLOSE_REQUEST_REJECTED
  CLOSE_REQUEST_CANCELLED
  FORCE_CLOSE_USED
}

// M12.4: Period Close Request Status
enum InventoryPeriodCloseRequestStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
  CANCELLED
}

// M12.4: Period Close Request - Approval workflow for period closing
model InventoryPeriodCloseRequest {
  id              String                              @id @default(cuid())
  orgId           String
  branchId        String
  periodId        String                              @unique // One request per period
  status          InventoryPeriodCloseRequestStatus   @default(DRAFT)
  requestedById   String
  requestedAt     DateTime?
  approvedById    String?
  approvedAt      DateTime?
  approvalNotes   String?
  rejectionReason String?
  createdAt       DateTime                            @default(now())
  updatedAt       DateTime                            @updatedAt

  // Relations
  org         Org             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch      Branch          @relation(fields: [branchId], references: [id], onDelete: Cascade)
  period      InventoryPeriod @relation(fields: [periodId], references: [id], onDelete: Cascade)
  requestedBy User            @relation("CloseRequestRequester", fields: [requestedById], references: [id], onDelete: Restrict)
  approvedBy  User?           @relation("CloseRequestApprover", fields: [approvedById], references: [id], onDelete: SetNull)

  @@index([orgId, branchId])
  @@index([status])
  @@map("inventory_period_close_requests")
}

// M12.2: Inventory Period Event - Audit-grade append-only event log
model InventoryPeriodEvent {
  id           String                     @id @default(cuid())
  orgId        String
  branchId     String
  periodId     String
  type         InventoryPeriodEventType
  actorUserId  String
  occurredAt   DateTime                   @default(now())
  reason       String?
  metadataJson Json?

  // Relations
  org    Org             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  branch Branch          @relation(fields: [branchId], references: [id], onDelete: Cascade)
  period InventoryPeriod @relation(fields: [periodId], references: [id], onDelete: Cascade)
  actor  User            @relation("PeriodEventActor", fields: [actorUserId], references: [id], onDelete: Restrict)

  @@index([orgId, branchId])
  @@index([periodId])
  @@map("inventory_period_events")
}

// M79: Immutability Audit Event - Audit trail for denied mutations in closed fiscal periods
// Records all attempts to mutate accounting data in closed periods
// Includes SHA-256 payload hash for forensic analysis
model ImmutabilityAuditEvent {
  id          String   @id @default(cuid())
  orgId       String
  actorId     String
  actorRole   String
  entityType  String // DepletionCostBreakdown, OrderInventoryDepletion, GoodsReceiptLineV2
  entityId    String
  operation   String // CREATE, UPDATE, DELETE, SOFT_DELETE, RESTORE
  periodId    String
  periodStart DateTime
  periodEnd   DateTime
  reasonCode  String // PERIOD_CLOSED_IMMUTABLE
  payloadHash String // SHA-256 of attempted change
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  @@index([orgId, createdAt])
  @@index([entityType, entityId])
  @@index([actorId])
  @@index([periodId])
  @@map("immutability_audit_events")
}

